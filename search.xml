<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/12/04/1106.html"/>
      <url>/2022/12/04/1106.html</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>使用栈来存储单调序列  </li><li>一般单调栈加二分较常见</li></ol><h2 id="单调队列（滑动窗口）"><a href="#单调队列（滑动窗口）" class="headerlink" title="单调队列（滑动窗口）"></a>单调队列（滑动窗口）</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><ol><li>找窗口最小值：当前元素比队尾元素更小时，队尾元素靠前并且还大，没有存在意义，当去除，由此队列是单调上升的，队头最小。</li><li>找窗口最大值：当前元素比队尾元素更大时，队尾元素靠前并且还更小，没有存在意义，当去除，由此队列是单调下降的，队头最大。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法</title>
      <link href="/2022/12/03/11306.html"/>
      <url>/2022/12/03/11306.html</url>
      
        <content type="html"><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a><font color=red>快排</font></h2><h3 id="快排思想"><a href="#快排思想" class="headerlink" title="快排思想"></a><font color=red>快排思想</font></h3><ol><li>在待排序序列中任意取出一个值，使在它左边的数都小于等于它，在它右边的数都大于等于它。  </li><li>对所有左侧的序列进行重复的操作，对右边也是一样。  </li><li>递归退出条件：当R&#x3D;&#x3D;L时此时一定有序，return。</li></ol><h3 id="快排板子"><a href="#快排板子" class="headerlink" title="快排板子"></a><font color=purple>快排板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int a[N];void speed_sort(int L,int R)&#123;    if(L&gt;=R)return;    int x=a[L+R&gt;&gt;1];    int i=L-1,j=R+1;    while(i&lt;j)&#123;        do(i++);while(a[i]&lt;x);        do(j--);while(a[j]&gt;x);        if(i&lt;j)&#123;            swap(a[i],a[j]);        &#125;    &#125;    speed_sort(L,j);    speed_sort(j+1,R);&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    speed_sort(1,n);    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;</code></pre><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color=red>归并排序</font></h2><h3 id="归并排序思想"><a href="#归并排序思想" class="headerlink" title="归并排序思想"></a><font color=puple>归并排序思想</font></h3><ol><li>根据两个有序序列，可以进行合并成一个有序序列。</li><li>先进行递归，递归到两个序列都只有一个元素为止，此时两个序列必定有序，进行合并。</li><li>回溯，用已经有序的左右两个序列合并为一个更大的序列，直到整个序列有序。</li></ol><h3 id="归并排序板子"><a href="#归并排序板子" class="headerlink" title="归并排序板子"></a><font color=red>归并排序板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n;int a[N],b[N];void merge_sort(int L,int R)&#123;    if(L&gt;=R)return;    int M=L+R&gt;&gt;1;    merge_sort(L,M);    merge_sort(M+1,R);    int i=L,j=M+1,k=0;    while(i&lt;=M&amp;&amp;j&lt;=R)&#123;        if(a[i]&lt;a[j])b[++k]=a[i++];        else b[++k]=a[j++];    &#125;    while(i&lt;=M)b[++k]=a[i++];    while(j&lt;=R)b[++k]=a[j++];    for(int i=1,j=L;i&lt;=k;i++,j++)&#123;        a[j]=b[i];    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    merge_sort(1,n);    for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    return 0;&#125;</code></pre><hr><h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a><font color=red>高精度算法</font></h1><h2 id="高精加法"><a href="#高精加法" class="headerlink" title="高精加法"></a><font color=red>高精加法</font></h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过模拟算术加法，每位对应相加，并加上前一位产生的进位</li></ol><h3 id="高精加板子①"><a href="#高精加板子①" class="headerlink" title="高精加板子①"></a><font color=red>高精加板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    //计算    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        c[i]+=a[i]+b[i];        c[i+1]+=c[i]/10;        c[i]=c[i]%10;    &#125;    if(c[len_c+1])len_c++;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精加板子②"><a href="#高精加板子②" class="headerlink" title="高精加板子②"></a><font color=red>高精加板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N=1e5+10;string s1,s2;vector&lt;int&gt;a,b,c;int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    len=s1.size();    len=max(len,int(s2.size()));    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a.push_back(s1[i]-&#39;0&#39;);    for(int i=s2.size()-1;i&gt;=0;i--)b.push_back(s2[i]-&#39;0&#39;);    //计算    int j=0;    for(int i=0;i&lt;len;i++)&#123;        int val=j;        if(i&lt;a.size())val+=a[i];        if(i&lt;b.size())val+=b[i];        j=val/10;        val%=10;        c.push_back(val);    &#125;    if(j)len++,c.push_back(j);    for(int i=len-1;i&gt;=0;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h2 id="高精减法"><a href="#高精减法" class="headerlink" title="高精减法"></a><font color=red>高精减法</font></h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>模拟算术中减法运算，逐位进行相减，不够减则向前一位借一当十使用。</li></ol><h3 id="高精减板子①"><a href="#高精减板子①" class="headerlink" title="高精减板子①"></a><font color=red>高精减板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //判断正负    bool isfu=false;    if(s1.size()==s2.size())&#123;        if(s2&gt;s1)&#123;            isfu=true;            swap(s1,s2);        &#125;    &#125;    else if(s1.size()&lt;s2.size())&#123;        isfu=true;        swap(s1,s2);    &#125;    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        //借一当十        while(a[i]-b[i]&lt;0)a[i+1]--,a[i]+=10;        c[i]=a[i]-b[i];    &#125;    //去除前导0    while(len_c&gt;1&amp;&amp;c[len_c]==0)len_c--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精减板子②"><a href="#高精减板子②" class="headerlink" title="高精减板子②"></a><font color=red>高精减板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;vector&lt;int&gt;a, b, c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    //判断正负    bool isfu = false;    if (s1.size() == s2.size()) &#123;        if (s2 &gt; s1) &#123;            isfu = true;            swap(s1, s2);        &#125;    &#125;    else if (s1.size() &lt; s2.size()) &#123;        isfu = true;        swap(s1, s2);    &#125;    int len = s1.size();    for (int i = s1.size() - 1; i &gt;= 0; i--)a.push_back(s1[i] - &#39;0&#39;);    for (int i = s2.size() - 1; i &gt;= 0; i--)b.push_back(s2[i] - &#39;0&#39;);    int j = 0;    for (int i = 0; i &lt; len; i++) &#123;        j = a[i] - j;        if (i &lt; b.size())j -= b[i];        c.push_back((j + 10) % 10);        if (j &lt; 0)j = 1;        else j = 0;    &#125;    while (len &gt; 1 &amp;&amp; c[len - 1] == 0)len--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for (int i = len - 1; i &gt;= 0; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h2 id="高精乘法"><a href="#高精乘法" class="headerlink" title="高精乘法"></a><font color=red>高精乘法</font></h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>关键c[i+j-1]+&#x3D;a[i]*b[j]</li></ol><h3 id="高精乘板子"><a href="#高精乘板子" class="headerlink" title="高精乘板子"></a><font color=red>高精乘板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;int a[N], b[N], c[N];int len_a, len_b, len_c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = s1.size()-1; i &gt;= 0; i--)a[++len_a] = s1[i] - &#39;0&#39;;    for (int i = s2.size()-1; i &gt;= 0; i--)b[++len_b] = s2[i] - &#39;0&#39;;    len_c = len_a + len_b;    for (int i = 1; i &lt;= len_a; i++) &#123;        for (int j = 1; j &lt;= len_b; j++) &#123;            c[i + j - 1] += a[i] * b[j];            c[i + j] += c[i + j - 1] / 10;            c[i + j - 1] %= 10;        &#125;    &#125;    while (c[len_c] == 0 &amp;&amp; len_c &gt; 1)len_c--;    for (int i = len_c; i &gt;= 1; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h2 id="高精除法（大整数-x2F-小整数）"><a href="#高精除法（大整数-x2F-小整数）" class="headerlink" title="高精除法（大整数&#x2F;小整数）"></a><font color=red>高精除法（大整数&#x2F;小整数）</font></h2><h3 id="高精除板子"><a href="#高精除板子" class="headerlink" title="高精除板子"></a><font color=red>高精除板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1;int b,a[N],c[N];int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;b;    for(int i=0;i&lt;=s1.size()-1;i++)a[++len]=s1[i]-&#39;0&#39;;    //余数    int yu=0;    for(int i=1;i&lt;=len;i++)&#123;        c[i]=(yu*10+a[i])/b;        yu=(yu*10+a[i])%b;    &#125;    int xb=0;    //注意前导0的去除    while(c[xb]==0&amp;&amp;xb&lt;len)xb++;    for(int i=xb;i&lt;=len;i++)cout&lt;&lt;c[i];    cout&lt;&lt;endl&lt;&lt;yu;    return 0;&#125;</code></pre><hr><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a><font color=red>一维前缀和</font></h2><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过计算前缀和，得到前缀和数组，可以计算任意区间的总和值。</li></ol><h3 id="一维前缀和板子"><a href="#一维前缀和板子" class="headerlink" title="一维前缀和板子"></a><font color=red>一维前缀和板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n,a[N],m;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],a[i]+=a[i-1];    while(m--)&#123;        int L,R;        cin&gt;&gt;L&gt;&gt;R;        cout&lt;&lt;a[R]-a[L-1]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a><font color=red>二维前缀和</font></h2><h3 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>前缀和b[i][j]&#x3D;b[i-1][j]+b[i][j-1]+a[i][j]</li><li>区间和b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]</li><li>画图便于理解</li></ol><h3 id="二维前缀和板子"><a href="#二维前缀和板子" class="headerlink" title="二维前缀和板子"></a><font color=red></font>二维前缀和板子</h3><pre><code>#include&lt;iostream&gt;using namespace std;int n,m,q;int a[1003][1003],b[1003][1003];int x1,y1,x2,y2;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;a[i][j];            b[i][j]=b[i-1][j]+b[i][j-1]+a[i][j]-b[i-1][j-1];        &#125;    &#125;    while(q--)&#123;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;        cout&lt;&lt;b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><hr><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a><font color=red>二分</font></h2><h3 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a><font color=puple>二分思想</font></h3><ol><li>对于某个单调序列，查找某个值x在序列中的大致位置（不保证序列中这个值一定存在）通过判断x与序列中点的值，从而确定下次去左半边区间找，还是去右半边区间找。这样最多只需要log(n)次便可找到。</li><li>需要特别注意边界问题，如下两个二分板子</li></ol><h3 id="二分板子"><a href="#二分板子" class="headerlink" title="二分板子"></a><font color=red>二分板子</font></h3><pre><code>int Find_1(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R&gt;&gt;1;        if(a[M]&gt;=x)R=M;        else L=M+1;    &#125;    return L;&#125;int Find_2(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R+1&gt;&gt;1;        if(a[M]&lt;=x)L=M;        else R=M-1;    &#125;    return L;&#125;</code></pre><hr><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a><font color=red>一维差分</font></h2><h3 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过b[L]+&#x3D;c;b[R+1]-&#x3D;c，对差分数组两端点修改，从而再利用前缀和达到对整个区间段修改。</li><li>复杂度降到O(1)</li></ol><h3 id="一维差分板子"><a href="#一维差分板子" class="headerlink" title="一维差分板子"></a><font color=red>一维差分板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n,m;int a[N],b[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    while(m--)&#123;        int L,R,c;        cin&gt;&gt;L&gt;&gt;R&gt;&gt;c;        b[L]+=c;b[R+1]-=c;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        b[i]+=b[i-1];        a[i]+=b[i];        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;</code></pre><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a><font color=red>二维差分</font></h2><h3 id="思想-6"><a href="#思想-6" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>核心：b[x1][y2+1]-&#x3D;c;<br> b[x2+1][y1]-&#x3D;c;<br> b[x1][y1]+&#x3D;c;<br> b[x2+1][y2+1]+&#x3D;c;</li></ol><h3 id="二维差分板子"><a href="#二维差分板子" class="headerlink" title="二维差分板子"></a><font color=red>二维差分板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;int a[1003][1003],b[1003][1003];int n,m,q;int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    while(q--)&#123;        int x1,y1,x2,y2,c;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;        b[x1][y2+1]-=c;        b[x2+1][y1]-=c;        b[x1][y1]+=c;        b[x2+1][y2+1]+=c;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];            a[i][j]+=b[i][j];            cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><hr><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><font color=red>双指针</font></h2><h3 id="思想-7"><a href="#思想-7" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li><p>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )<br> {<br> while (j &lt; i &amp;&amp; check(i, j)) j ++ ;</p><p> &#x2F;&#x2F; 具体问题的逻辑}</p></li></ol><hr><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a><font color=red>二进制</font></h2><h3 id="lowbit求二进制表示中最后一个一的位置"><a href="#lowbit求二进制表示中最后一个一的位置" class="headerlink" title="lowbit求二进制表示中最后一个一的位置"></a><font color=puple>lowbit求二进制表示中最后一个一的位置</font></h3><ol><li>int lowbit(int x){<br> return x&amp;-x;<br>}</li></ol><hr><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><h3 id="思想-8"><a href="#思想-8" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>适用类型：范围很大的一组数据，但是总个数少。</li><li>将原先一组数据映射到新的数组中，根据需要进行排序或去重，可以在排序后通过二分找到原先数组中对应元素在新数组中对应的位置，从而进行后续的操作。</li></ol><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ol><li><font color=puple>排序</font>：sort(num.begin(),num.end());</li><li><font color=puple>去重</font>：num.erase(unique(num.begin(),num.end()),num.end());</li></ol><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
