<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高精度</title>
      <link href="/2022/12/04/40472.html"/>
      <url>/2022/12/04/40472.html</url>
      
        <content type="html"><![CDATA[<h1 id="高精加法"><a href="#高精加法" class="headerlink" title="高精加法"></a><font color=red>高精加法</font></h1><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过模拟算术加法，每位对应相加，并加上前一位产生的进位</li></ol><h3 id="高精加板子①"><a href="#高精加板子①" class="headerlink" title="高精加板子①"></a><font color=red>高精加板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    //计算    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        c[i]+=a[i]+b[i];        c[i+1]+=c[i]/10;        c[i]=c[i]%10;    &#125;    if(c[len_c+1])len_c++;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精加板子②"><a href="#高精加板子②" class="headerlink" title="高精加板子②"></a><font color=red>高精加板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N=1e5+10;string s1,s2;vector&lt;int&gt;a,b,c;int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    len=s1.size();    len=max(len,int(s2.size()));    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a.push_back(s1[i]-&#39;0&#39;);    for(int i=s2.size()-1;i&gt;=0;i--)b.push_back(s2[i]-&#39;0&#39;);    //计算    int j=0;    for(int i=0;i&lt;len;i++)&#123;        int val=j;        if(i&lt;a.size())val+=a[i];        if(i&lt;b.size())val+=b[i];        j=val/10;        val%=10;        c.push_back(val);    &#125;    if(j)len++,c.push_back(j);    for(int i=len-1;i&gt;=0;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h1 id="高精减法"><a href="#高精减法" class="headerlink" title="高精减法"></a><font color=red>高精减法</font></h1><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>模拟算术中减法运算，逐位进行相减，不够减则向前一位借一当十使用。</li></ol><h3 id="高精减板子①"><a href="#高精减板子①" class="headerlink" title="高精减板子①"></a><font color=red>高精减板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //判断正负    bool isfu=false;    if(s1.size()==s2.size())&#123;        if(s2&gt;s1)&#123;            isfu=true;            swap(s1,s2);        &#125;    &#125;    else if(s1.size()&lt;s2.size())&#123;        isfu=true;        swap(s1,s2);    &#125;    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        //借一当十        while(a[i]-b[i]&lt;0)a[i+1]--,a[i]+=10;        c[i]=a[i]-b[i];    &#125;    //去除前导0    while(len_c&gt;1&amp;&amp;c[len_c]==0)len_c--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精减板子②"><a href="#高精减板子②" class="headerlink" title="高精减板子②"></a><font color=red>高精减板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;vector&lt;int&gt;a, b, c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    //判断正负    bool isfu = false;    if (s1.size() == s2.size()) &#123;        if (s2 &gt; s1) &#123;            isfu = true;            swap(s1, s2);        &#125;    &#125;    else if (s1.size() &lt; s2.size()) &#123;        isfu = true;        swap(s1, s2);    &#125;    int len = s1.size();    for (int i = s1.size() - 1; i &gt;= 0; i--)a.push_back(s1[i] - &#39;0&#39;);    for (int i = s2.size() - 1; i &gt;= 0; i--)b.push_back(s2[i] - &#39;0&#39;);    int j = 0;    for (int i = 0; i &lt; len; i++) &#123;        j = a[i] - j;        if (i &lt; b.size())j -= b[i];        c.push_back((j + 10) % 10);        if (j &lt; 0)j = 1;        else j = 0;    &#125;    while (len &gt; 1 &amp;&amp; c[len - 1] == 0)len--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for (int i = len - 1; i &gt;= 0; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h1 id="高精乘法"><a href="#高精乘法" class="headerlink" title="高精乘法"></a><font color=red>高精乘法</font></h1><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>关键c[i+j-1]+&#x3D;a[i]*b[j]</li></ol><h3 id="高精乘板子"><a href="#高精乘板子" class="headerlink" title="高精乘板子"></a><font color=red>高精乘板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;int a[N], b[N], c[N];int len_a, len_b, len_c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = s1.size()-1; i &gt;= 0; i--)a[++len_a] = s1[i] - &#39;0&#39;;    for (int i = s2.size()-1; i &gt;= 0; i--)b[++len_b] = s2[i] - &#39;0&#39;;    len_c = len_a + len_b;    for (int i = 1; i &lt;= len_a; i++) &#123;        for (int j = 1; j &lt;= len_b; j++) &#123;            c[i + j - 1] += a[i] * b[j];            c[i + j] += c[i + j - 1] / 10;            c[i + j - 1] %= 10;        &#125;    &#125;    while (c[len_c] == 0 &amp;&amp; len_c &gt; 1)len_c--;    for (int i = len_c; i &gt;= 1; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h1 id="高精除法（大整数-x2F-小整数）"><a href="#高精除法（大整数-x2F-小整数）" class="headerlink" title="高精除法（大整数&#x2F;小整数）"></a><font color=red>高精除法（大整数&#x2F;小整数）</font></h1><h3 id="高精除板子"><a href="#高精除板子" class="headerlink" title="高精除板子"></a><font color=red>高精除板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1;int b,a[N],c[N];int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;b;    for(int i=0;i&lt;=s1.size()-1;i++)a[++len]=s1[i]-&#39;0&#39;;    //余数    int yu=0;    for(int i=1;i&lt;=len;i++)&#123;        c[i]=(yu*10+a[i])/b;        yu=(yu*10+a[i])%b;    &#125;    int xb=0;    //注意前导0的去除    while(c[xb]==0&amp;&amp;xb&lt;len)xb++;    for(int i=xb;i&lt;=len;i++)cout&lt;&lt;c[i];    cout&lt;&lt;endl&lt;&lt;yu;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="/2022/12/04/64018.html"/>
      <url>/2022/12/04/64018.html</url>
      
        <content type="html"><![CDATA[<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a><font color=red>二分</font></h1><h3 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a><font color=puple>二分思想</font></h3><ol><li>对于某个单调序列，查找某个值x在序列中的大致位置（不保证序列中这个值一定存在）通过判断x与序列中点的值，从而确定下次去左半边区间找，还是去右半边区间找。这样最多只需要log(n)次便可找到。</li><li>需要特别注意边界问题，如下两个二分板子</li></ol><h3 id="二分板子"><a href="#二分板子" class="headerlink" title="二分板子"></a><font color=red>二分板子</font></h3><pre><code>int Find_1(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R&gt;&gt;1;        if(a[M]&gt;=x)R=M;        else L=M+1;    &#125;    return L;&#125;int Find_2(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R+1&gt;&gt;1;        if(a[M]&lt;=x)L=M;        else R=M-1;    &#125;    return L;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2022/12/04/63711.html"/>
      <url>/2022/12/04/63711.html</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color=red>归并排序</font></h1><h3 id="归并排序思想"><a href="#归并排序思想" class="headerlink" title="归并排序思想"></a><font color=puple>归并排序思想</font></h3><ol><li>根据两个有序序列，可以进行合并成一个有序序列。</li><li>先进行递归，递归到两个序列都只有一个元素为止，此时两个序列必定有序，进行合并。</li><li>回溯，用已经有序的左右两个序列合并为一个更大的序列，直到整个序列有序。</li></ol><h3 id="归并排序板子"><a href="#归并排序板子" class="headerlink" title="归并排序板子"></a><font color=red>归并排序板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n;int a[N],b[N];void merge_sort(int L,int R)&#123;    if(L&gt;=R)return;    int M=L+R&gt;&gt;1;    merge_sort(L,M);    merge_sort(M+1,R);    int i=L,j=M+1,k=0;    while(i&lt;=M&amp;&amp;j&lt;=R)&#123;        if(a[i]&lt;a[j])b[++k]=a[i++];        else b[++k]=a[j++];    &#125;    while(i&lt;=M)b[++k]=a[i++];    while(j&lt;=R)b[++k]=a[j++];    for(int i=1,j=L;i&lt;=k;i++,j++)&#123;        a[j]=b[i];    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    merge_sort(1,n);    for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2022/12/03/11306.html"/>
      <url>/2022/12/03/11306.html</url>
      
        <content type="html"><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><h3 id="快排思想"><a href="#快排思想" class="headerlink" title="快排思想"></a><font color=red>快排思想</font></h3><ol><li>在待排序序列中任意取出一个值，使在它左边的数都小于等于它，在它右边的数都大于等于它。  </li><li>对所有左侧的序列进行重复的操作，对右边也是一样。  </li><li>递归退出条件：当R&#x3D;&#x3D;L时此时一定有序，return。</li></ol><h3 id="快排板子"><a href="#快排板子" class="headerlink" title="快排板子"></a><font color=purple>快排板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int a[N];void speed_sort(int L,int R)&#123;    if(L&gt;=R)return;    int x=a[L+R&gt;&gt;1];    int i=L-1,j=R+1;    while(i&lt;j)&#123;        do(i++);while(a[i]&lt;x);        do(j--);while(a[j]&gt;x);        if(i&lt;j)&#123;            swap(a[i],a[j]);        &#125;    &#125;    speed_sort(L,j);    speed_sort(j+1,R);&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    speed_sort(1,n);    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
