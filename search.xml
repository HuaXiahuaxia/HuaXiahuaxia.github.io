<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/02/13/28758.html"/>
      <url>/2023/02/13/28758.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="计算机网络在信息时代的作用"><a href="#计算机网络在信息时代的作用" class="headerlink" title="计算机网络在信息时代的作用"></a>计算机网络在信息时代的作用</h2><ul><li>为我们提供浏览信息和发布信息的平台</li><li>为我们提供通信和交流的平台</li><li>为我们提供休闲和娱乐的平台</li><li>为我们提供资源共享的平台</li><li>为我们提供电子商务的平台</li><li>为我们提供远程协作的平台</li><li>为我们提供网上办公的平台</li></ul><h2 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h2><ul><li>是利用通信设备和通信线路将地理上分散的，具有独立功能多个计算机系统按不同的形式连接起来，以功能完善的网络软件和通信协议实现资源共享和信息传递的系统</li></ul><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="按覆盖范围分"><a href="#按覆盖范围分" class="headerlink" title="按覆盖范围分"></a>按覆盖范围分</h3><ul><li>局域网</li><li>城域网</li><li>广域网</li><li>个人区域网</li></ul><h3 id="按网络使用者分"><a href="#按网络使用者分" class="headerlink" title="按网络使用者分"></a>按网络使用者分</h3><ul><li>共用网</li><li>专用网</li></ul><hr><blockquote><p>Tips：网络 ——&gt; 互联网络 ——&gt; 互联网（世界上最大的互联网络）</p></blockquote><hr><h2 id="互联网从功能上划分"><a href="#互联网从功能上划分" class="headerlink" title="互联网从功能上划分"></a>互联网从功能上划分</h2><ul><li>边缘部分：由所有连接在其上的主机组成</li><li>核心部分：起特殊作用的路由器</li></ul><h2 id="计算机网络的主要性能指标"><a href="#计算机网络的主要性能指标" class="headerlink" title="计算机网络的主要性能指标"></a>计算机网络的主要性能指标</h2><ul><li>速率：指数居的传送速率，也叫数据率或比特率，常说的网络速率是指Mb而不是MB（需要除8）</li><li>带宽：指某信号具有的频带宽度（如说话频率在300HZ~3.4KHZ），也指网络通道传送数据的能力，表示在单位时间从网络中某一点到另一点所能通过的“最高数据率”，单位“比特每秒”</li><li>吞吐量：在确定时间段内，能够传输数据的能力<blockquote><p>Tips: 带宽和吞吐量的区别：带宽指最大速率，吞吐量指某时刻速率，例子：带宽比作马路，路有多宽是固定的，吞吐量就是车流量，不能比道路宽，每个时刻的流量可能是不同的。  </p></blockquote></li><li>时延：从网络的一端传送到另一端需要的时间<blockquote><p>Tips 时延的组成部分 ：<br>发送时延：也叫传输时延，指主机或路由器将整个分组发送到通信线路所需的时间<br>传播时延：电磁波在信道中传播一定距离的时间<br>处理时延：主机或路由器需要花时间对分组进行处理<br>排队时延：分组在路由器中，要在输出队列中排队，确定转发接口后，要在输出队列中排队</p></blockquote></li></ul><blockquote><p>Tips: 在高带宽链路中，比特应当跑的快一点（错的），在高速链路中，我们提高的只是发送速率，而在链路中的传播速率是由介质决定的<br>Tips: 光纤的传输速率高，指他的发送速率高，他的传播速率其实比铜还慢</p></blockquote><ul><li>去包率：即分组丢失率，值在一定时间范围内，分组在传输中丢失的分组数量与总的分组数量的比率<blockquote><p>Tips：丢包原因：<br>在传输过程中出现比特级差错<br>分组交换机中队列满了，后面来的分组就会丢弃<br>由于不是电路交换那样，建立连接，因而会有网络拥塞导致分组交换机的队列溢出和分组丢失</p></blockquote></li><li>利用率：<br>信道利用率：信道有百分之几的时间是被利用的<br>网络利用率：指全网络信道利用率加权平均值<blockquote><p>Tips：信道利用率或网络利用率过高会产生很大时延</p></blockquote></li></ul><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><ul><li>含义：计算机网络的层次结构模型与各层协议的集合称为计算机网络的体系结构</li></ul><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><ul><li>计算机网络由多个互连的节点组成，节点之间要不断交换数据和控制信息，每个节点需要遵守约定的规则，这些规则规定了交换的数据的格式和时序，以及在发送或接收时要采取的动作</li></ul><h3 id="网络协议三要素"><a href="#网络协议三要素" class="headerlink" title="网络协议三要素"></a>网络协议三要素</h3><ul><li>语法：数据和控制信息的结构或格式</li><li>语义：各种控制信息的具体含义</li><li>同步：即事件实现的顺序和时间的详细说明</li></ul><h3 id="按层次涉及计算机网络的好处"><a href="#按层次涉及计算机网络的好处" class="headerlink" title="按层次涉及计算机网络的好处"></a>按层次涉及计算机网络的好处</h3><ul><li>各层次之间独立</li><li>灵活性好</li><li>结构上可分隔开</li><li>易于实现和维护</li><li>有利于功能复用</li><li>能促进标准化工作</li></ul><h2 id="几种计算机网络体系结构"><a href="#几种计算机网络体系结构" class="headerlink" title="几种计算机网络体系结构"></a>几种计算机网络体系结构</h2><h3 id="OSIC开放系统互连系统参考模型"><a href="#OSIC开放系统互连系统参考模型" class="headerlink" title="OSIC开放系统互连系统参考模型"></a>OSIC开放系统互连系统参考模型</h3><pre><code>应用层表示层会话层运输层网络层数据链路层物理层</code></pre><h3 id="TCP-x2F-IP体系结构"><a href="#TCP-x2F-IP体系结构" class="headerlink" title="TCP&#x2F;IP体系结构"></a>TCP&#x2F;IP体系结构</h3><pre><code>应用层运输层网际层网络接口层</code></pre><h3 id="原理体系结构"><a href="#原理体系结构" class="headerlink" title="原理体系结构"></a>原理体系结构</h3><pre><code>应用层运输层网络层数据链路层物理层</code></pre><h2 id="原理体系结构每层大致作用"><a href="#原理体系结构每层大致作用" class="headerlink" title="原理体系结构每层大致作用"></a>原理体系结构每层大致作用</h2><ul><li>物理层：在传输媒体上传输比特流，需考虑传输媒体的类型</li><li>数据链路层：将分组从链路一端送到另一端（相邻两个节点间的链路），传送以帧为单位的数据</li><li>网络层：即网际层，负责为分组交换网上不同主机提供通信服务，将运输层的报文段或用户数据报封装为包或分组传送，也叫数据报，中间需要选择合适的路由传送</li><li>运输层：即传输层，是向两台主机中进程之间的通信提供的数据传输服务<blockquote><p>Tips：两个重要的运输层协议<br>传输控制协议（TCP）：面向连接，可靠的数据传输服务，传输单位是报文段<br>用户数据报协议（UDP）：面向无连接，尽最大努力的数据传输服务，传输单位是用户数据报</p></blockquote></li><li>应用层：是通过应用进程间的交互来完成特定的网络应用<blockquote><p>Tips：应用层交互的数据单元为报文</p></blockquote></li></ul><hr><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="物理层需要考虑的问题"><a href="#物理层需要考虑的问题" class="headerlink" title="物理层需要考虑的问题"></a>物理层需要考虑的问题</h2><ul><li>传输媒体的类型</li><li>位的表示，即如何编码</li><li>数据率，规定每秒发送的比特数（发送方和接收方应保持相同）</li><li>位同步，发送方的时钟与接收方的时钟要保持一致</li><li>链路配置<blockquote><p>点到点配置中，两个设备通过一条专用链路连接<br>多点配置中，多设备共享一条链路</p></blockquote></li><li>物理拓扑结构：网络的拓扑结构</li><li>传输方式，串行与并行传输</li><li>与传输媒体的接口类型</li></ul><h2 id="两种信号"><a href="#两种信号" class="headerlink" title="两种信号"></a>两种信号</h2><ul><li>模拟信号（连续信号）：信息的参数的取值是连续的</li><li>数字信号（离散信号）：消息的参数的取值是离散的<blockquote><p>Tips:<br>数字数据经过编码成数字信号<br>数字数据经过调制成模拟信号</p></blockquote></li></ul><h2 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h2><ul><li>归零制，正脉冲代表1，负脉冲代表0</li><li>不归零制，正点平代表1，负电平代表0</li><li>曼彻斯特编码，位周期中心的上跳变代表0，下跳变代表1</li><li>查分曼彻斯特编码，每一位中心都有跳变，位开始边界有跳变代表0，没有代表1</li></ul><h2 id="基本调制方式"><a href="#基本调制方式" class="headerlink" title="基本调制方式"></a>基本调制方式</h2><blockquote><p>矩形脉冲波形的数字信号包含从直流开始的低频分量，称为基带信号，需要经过调制，才可以在模拟信道传输</p></blockquote><ul><li>带通调制，使用载波调制（调幅，调频，调相）</li><li>正交振幅调制</li></ul><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><blockquote><p>码元是承载信息的基本信号单位，一个码元能承载信息量的多少，由码元信号能表示的数据有限状态个数决定的<br>未提高信息的传输速率，我们总希望一定时间传输更多的码元，但实际上，码元传输率越高，信道传输距离越远，噪声干扰越大，在信道输出端的波形失真越严重</p></blockquote><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><blockquote><p>理想低通信道的最高码元传输速率 &#x3D; 2W（波特）W为信道带宽<br>Tips：要提高信息传输速率，就要让每个码元携带更多个比特的信息量，但采用多元制并不能无限提高信息传输速率，信息传输速率还局限于信噪比</p></blockquote><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><blockquote><p>C &#x3D; W log $_2$(1+S&#x2F;N)（bit&#x2F;s） S为信道内所传送信号的平均功率，N为信道内的高斯噪声功率</p></blockquote><blockquote><p>异步传输与同步传输是采用两种不同的同步传输方式传输<br>  异步：以字节为独立的传输单位，字节内实现同步<br>  同步：以比特流为单位，直接实现同步</p></blockquote><h2 id="光纤的特点"><a href="#光纤的特点" class="headerlink" title="光纤的特点"></a>光纤的特点</h2><ul><li>通信容量非常大</li><li>传输损耗小，远距离传输更经济</li><li>无串音干扰，保密性好</li><li>抗雷电和电磁干扰好</li><li>体积小，重量轻</li></ul><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><blockquote><p>当网络传输媒体的传输容量大于多条单一信道的总通信量时，利用信道复用技术在一条物理线路建立多条通信信道来充分利用传输媒体的带宽</p></blockquote><h2 id="复用技术"><a href="#复用技术" class="headerlink" title="复用技术"></a>复用技术</h2><ul><li>频分复用：就是将传输线路的频带资源划分成多个子频带，形成多个子信道，要求频带宽度大于各个子信道频带宽度之和</li><li>时分复用：将传输线路的宽带资源按时间轮流分配给不同用户，每个用户只在分配的时间里才可以使用线路传输数据，时分复用的用户在每一个TDM帧（时分复用帧）中占固定信号的时隙</li><li>统计时分复用：改进的时分复用，使用（STDM帧）按需动态分配时隙</li><li>波分复用：即光的频分复用</li><li>码分复用：也叫码分多址，每一个用户可在同样的时间使用同样的频带通信，由于各个用户使用特殊挑选的不同码型，因此各用户之间不会造成干扰</li></ul><blockquote><p>Tips：两类扩频通路<br>  直接序列：如码片序列，将每一位bit0或1分成m个短的时隙，称为码片，则发送速率会翻m倍，频带宽度会翻m倍，不同的发送站台的码片序列不仅要互不相同，而且要相互正交，即内积为0<br>  跳频</p></blockquote><h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><ul><li>将用户设备连接到ISP边缘路由器的物理链路及相关设备的集合称为接入网</li></ul><blockquote><p>目前的接入技术<br>  电话网拨号介入<br>  数字用户线接入<br>  光纤同轴混合网线接入<br>  光纤接入<br>  以太网接入<br>  无线接入（基于IEEE802.11技术的无线局域网，也叫wi-fi）和（蜂窝移动通信系统接入，也叫移动通信）</p></blockquote><hr><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h2><blockquote><p>有一条物理线路，还必须有一些通信协议来控制数据传输，现在常用的是网络适配器实现协议</p></blockquote><blockquote><p>Tips：点对点的数据链路层通信步骤：<br>  节点A的数据链路层把网络层交下来IP数据报添加首部和尾部封装成帧<br>  节点A把封装好的帧发送到节点B的数据链路层<br>  若节点B的数据链路层收到的帧无差错，则节点B从收到帧中提取出IP数据报上交给上面的网络层</p></blockquote><h2 id="帧定界"><a href="#帧定界" class="headerlink" title="帧定界"></a>帧定界</h2><ul><li>数据链路层为IP数据报添加首部和尾部后，封装成一个完整的帧，因此数据链路层必须正确识别每个帧的开始和结束，即帧定界</li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><ul><li>发送的数据中不能出现帧定界符，及对上层交给的数据没有任何限制</li><li>字节填充或字符填充，即添加转义字符标记帧定界符（面向字符的链路）</li><li>帧定界采用某个特殊的比特组合（面向比特的链路）</li></ul><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><ul><li>利用差错检测码<blockquote><p>如：<br>需要发送数据D，差错检测码为EDC&#x3D;f$(D)$，判断接受数据D$^{’}$，和接收到的EDC$^{’}$是否等于$f(D^{’})$</p></blockquote></li><li>循环冗余检验（CRC）：通常在帧尾部设置一个差错检验字段<blockquote><p>例如：<br>D&#x3D;101001，G&#x3D;1101（协商得来），计算D$^{’}$&#x3D;101001000,R（余数）&#x3D;D$^{’}$ mod G&#x3D;001，将R加到D$^{’}$，得到D$^{’}$&#x3D;101001001，最终只需要判断D$^{’}$ mod R是否等于0即可</p></blockquote></li></ul><blockquote><p>可靠传输<br>  及发送端发送什么，对应的接收端就接受什么</p></blockquote><h2 id="实现可靠传输"><a href="#实现可靠传输" class="headerlink" title="实现可靠传输"></a>实现可靠传输</h2><ul><li>停止等待协议：发送方每发送一个数据，等待接收方发送回应ACK&#x2F;NAK，当数据分组或确认分组丢失时，采用超时重传解决，如果是确认分组丢失，为防止收到重复分组，发送方给每一个分组不同的发送序号，来丢弃重复分组<blockquote><p>停止等待协议的信道利用率：<br>发送分组需要时间$T_{A}$，来回往返需要时间RTT，接收方发送确认分组需要$T_{B}$，则信道的利用率为U&#x3D;$T_{A} &#x2F; (T_{A}+T_{B}+RTT)$</p></blockquote></li><li>回退N帧协议：又叫滑动窗口协议，是在流水线（即发送方可连续发送多个分组）传输的基础上，利用发送窗口来限制发送方连续发送分组的个数，是一种ARQ协议<blockquote><p>原理：是允许发送方已发送但还没有收到确认的分组序号的范围，窗口大小就是发送方已发送但还没有收到确认的最大分组数</p></blockquote></li><li>选择重传协议：只选择出现差错的分组进行重传，这时接收端窗口大小不再是1，以便收下失序到达但仍然处在接受窗口中的分组，等到所缺分组收齐后再一并送交上层</li></ul><h2 id="点对点协议（PPP）"><a href="#点对点协议（PPP）" class="headerlink" title="点对点协议（PPP）"></a>点对点协议（PPP）</h2><ul><li>用户计算机和ISP进行通话时，通常使用的数据链路层协议</li></ul><h3 id="ppp的特点"><a href="#ppp的特点" class="headerlink" title="ppp的特点"></a>ppp的特点</h3><ul><li>简单，每接受一帧，进行一次CRC，使用PPP的数据链路层向上不提供可靠传输服务，若需要提供可靠传输服务，则有运输层完成</li><li>封装成帧，使用特殊字符作为帧定界符</li><li>透明性，保证透明传输（发送的数据中不含有帧定界符）</li><li>多种网络层协议和多种类型链路，PPP可以在同一条物理链路上同时支持多种网络层协议，并可在多种类型的点对点链路上运行</li><li>接受端能进行差错检测</li><li>可以检测连接状态</li><li>最大传送单元，即接收的分组最大长度（MTU）</li><li>网络层地址协商</li></ul><h3 id="PPP的组成"><a href="#PPP的组成" class="headerlink" title="PPP的组成"></a>PPP的组成</h3><ul><li>一个IP数据报</li><li>一个用来建立，配置和测试数据链路连接的链路控制协议（LCP）</li><li>一套网络控制协议（NCP）</li></ul><h2 id="使用广播的数据链路层"><a href="#使用广播的数据链路层" class="headerlink" title="使用广播的数据链路层"></a>使用广播的数据链路层</h2><blockquote><p>媒体接入控制或多址接入，问题：多个站点发送数据共享信道上信号冲突问题，即如何协调多个发送站点和多个接收站点对一个共享媒体的占用<br>媒体接入控制两大类方法<br>  静态划分信道（频分多址，时分多址，码分多址）<br>  动态接入控制（各站点动态占用信道发送数据）</p></blockquote><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><blockquote><p>局域网的数据链路层<br>  逻辑链路控制子层（LLC）<br>  媒体接入控制子层（MAC）</p></blockquote><blockquote><p>局域网对LLC子层来说是透明的，LLC子层可以为不同类型的网络层协议提供不同类型的数据传输服务</p></blockquote><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><blockquote><p>MAC地址（硬件物理地址）：<br>  当多站点连接在同一个广播信道上时，要实现两站点的通信，每个站点都必须有唯一的标识，即哪一个数据链路层地址（固化在适配器ROM（只读存储器）中的地址）</p></blockquote><blockquote><p>Tips：适配器具有过滤功能<br>  从网络上每收到一个MAC帧，就先用硬件检查MAC帧中的目的地址，是不是发往本站<br>  发往本站：<br>  单播：收到的MAC帧与本站的相同<br>  广播：发送给局域网上所有站点的帧<br>  多播：发送给本局域网上一部分站点的帧</p></blockquote><h2 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h2><h3 id="以太网采取的两种措施"><a href="#以太网采取的两种措施" class="headerlink" title="以太网采取的两种措施"></a>以太网采取的两种措施</h3><ul><li>采用较灵活的无连接工作方式，即不建立连接，发送的数据帧不编号，也不要求对方发回确认帧，以太网提供的服务是不可靠的交付，是尽最大努力的交付</li><li>采用基带传输，发送的数据使用曼彻斯特编码</li></ul><h3 id="媒体接入控制协议"><a href="#媒体接入控制协议" class="headerlink" title="媒体接入控制协议"></a>媒体接入控制协议</h3><ul><li>解决同一时间只允许一个站点发送数据的问题</li><li>载波监听多址接入&#x2F;冲突检测协议（CSMA&#x2F;CD）<blockquote><p>协议要点<br>多址接入，许多站点以多址接入的方式连接在一根总线上<br>载波监听，即“发送前先监听”，即在发送前，用电子技术检测总线上有没有其他站点发送数据信号<br>冲突检测，即“边发送边监听”，也叫碰撞检测，一旦发现总线上出现冲突，适配器就要立即停止发送，等待一段随机时间再发送</p></blockquote></li></ul><blockquote><p>争用期：<br>  以太网的端到端（最远的）的往返时间为2t，又叫冲突窗口，站点发完数据，需经过一个争用期才可以肯定没有发生冲突</p></blockquote><h3 id="截断二进制退避算法"><a href="#截断二进制退避算法" class="headerlink" title="截断二进制退避算法"></a>截断二进制退避算法</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数论</title>
      <link href="/2022/12/08/26496.html"/>
      <url>/2022/12/08/26496.html</url>
      
        <content type="html"><![CDATA[<h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><ol><li>任何数均能被他的质因子筛去。</li></ol><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><ol><li>任何数均能被他的最小质因子筛去。</li></ol><hr><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h3><ol><li>N&#x3D;${p_1}^{a_1}\times{p_1}^{a_1}\times{p_1}^{a_1}\cdots\times{p_n}^{a_n}$这里$p_i$表示N的质因子，$a_i$表示质因子个数。  </li><li>任何数都可以表示成他的质因数乘积</li></ol><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><ol><li>即质因子的排列组合，有${a_1+1}\times{a_2+1}\times\cdots\times{a_n+1}$种可能，由于是质因子的排列组合，不可能存在有重复答案的排列。</li></ol><h3 id="约数和"><a href="#约数和" class="headerlink" title="约数和"></a>约数和</h3><ol><li>即各排列组合的约数之和，有sum&#x3D;${p_1^0+p_1^1+\cdots+p_1^{a_1}}+{p_2^0+p_2^1+\cdots+p_2^{a_2}}+\cdots$。</li></ol><hr><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><pre><code>int gcd(int a,int b)&#123;    return b==0?a:gcd(b,a%b);&#125;</code></pre><hr><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>phi[n]表示1到n中与n互质的数个数。</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>容斥原理，N&#x3D;${p_1}^{a_1}\times{p_1}^{a_1}\times{p_1}^{a_1}\cdots\times{p_n}^{a_n}$，有N&#x2F;$p_1$个合数，N&#x2F;$p_2$个合数….,这些都要减去，即N-N&#x2F;$p_1$-N&#x2F;$p_2$….，对于N&#x2F;($p_i<em>p_j$)这些数都被重复减去，需要加回来，同理N&#x2F;($p_i</em>p_j*p_k$)需要减去，以此类推。</li><li>答案ans&#x3D;$N\times{(1-1\div p_1)}\times{(1-1\div p_2)}\times\cdots {(1-1\div p_n)}$。</li></ol><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><ol><li>$a^{phi[n]}$%n&#x3D;&#x3D;1，即同余1模n。</li></ol><hr><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><ol><li>11的二进制表示：1011，则$2^{11}$&#x3D;$2^1\times2^2\times2^8$。</li></ol><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><pre><code>void speed_pow(int a,int b,int p)&#123;    long long ans=1,sum=a;    while(b)&#123;        if(b&amp;1)ans=(ans%p*sum)%p;        b&gt;&gt;=1;        sum=sum%p*sum%p;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return;&#125;</code></pre><hr><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h4><ol><li>乘法逆元：$x\times x^{-1}\equiv $ 1(%m)，这里 $x^{-1}$即x的逆元，x与m必须互质才存在逆元。</li><li>证明x与m必须互质：<br>证：假设不互质则有gcd(a,m)&gt;1，令b&#x3D;$a^{-1}$,有a<em>b&#x3D;q</em>m+1;有ab-qm&#x3D;1;因为a,m,有最大公因子大于1，但是右侧1没有大于1的因子，因此与假设矛盾，故x与m必须要互质才存在逆元。</li></ol><h4 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h4><ol><li>对于任意正整数a,b,一定存在整数x,y,使得ax+by&#x3D;gcd(a,b)。</li></ol><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><ol><li>使用欧几里得算法的同时可以通过回溯得到ax+by&#x3D;gcd(a,b)的一组x,y解。</li></ol><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol><li>x $\equiv a_1(mod m_1)$，x $\equiv a_1(mod m_1)$，x $\equiv a_1(mod m_1)$…..，x $\equiv a_n(mod m_n)$，令M&#x3D;m1<em>m2</em>…mn，则有 $M_i$&#x3D;M&#x2F;$m_i$，则x&#x3D;$a_1\times M_1\times M_1^{-1}+a_2\times M_2\times M_2^{-1}+\dots +a_n\times M_n\times M_n^{-1}$。（前提逆元存在，即$m_i$两两互质）</li></ol><h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><ol><li>不保证$m_i$两两互质，若有n个同余式，则每两个可以合并成一个同余式，这样n个同余式最后只会剩一个，这个即为答案。</li></ol><hr><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>使用线性代数初等行变换</li><li>使行列式变成阶梯状</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>枚举每一列</li><li>找到该列绝对值最大的一行</li><li>将该行换到上面</li><li>将下面所有行的这列消成0</li></ol><h3 id="判断解"><a href="#判断解" class="headerlink" title="判断解"></a>判断解</h3><ol><li>完美阶梯状——唯一解</li><li>否则，出现左右等式出现0&#x3D;&#x3D;非0——无解</li><li>否则，——有无穷多组解</li></ol><h3 id="唯一解计算ans"><a href="#唯一解计算ans" class="headerlink" title="唯一解计算ans"></a>唯一解计算ans</h3><ol><li>从最后一行向上把$x_i$解出来</li><li>若当前列不等于0，则需要对应的该列为1的那一行来消除</li><li>最后$x_i{_n}$即为答案</li></ol><hr><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><h3 id="方法一——杨辉三角"><a href="#方法一——杨辉三角" class="headerlink" title="方法一——杨辉三角"></a>方法一——杨辉三角</h3><ol><li>C $i\choose n$&#x3D;C $i\choose n-1$+C $i-1\choose n-1$</li></ol><h3 id="方法2——逆元"><a href="#方法2——逆元" class="headerlink" title="方法2——逆元"></a>方法2——逆元</h3><ol><li>C $b\choose a$&#x3D;$a!\over b!\times {(a-b)}!$&#x3D;$a!\times b!^{-1}\times {(a-b)!^{-1}}$</li><li>前提：mod(n)中n为质数，利用费马小定理+快速幂求逆元</li></ol><h3 id="方法3——卢卡斯定理"><a href="#方法3——卢卡斯定理" class="headerlink" title="方法3——卢卡斯定理"></a>方法3——卢卡斯定理</h3><ol><li>C $b\choose a$&#x3D;C $b\mod p\choose a\mod p$ *C $b&#x2F;p \choose a&#x2F;p$(mod p)</li></ol><hr><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><ol><li>$s_1\cup s_2\dots \cup s_n$&#x3D;$\sum s_i$-$\sum s_i\cap s_j$+$\dots$ $\pm \sum s_i\cap s_j\cap \dots \cap s_r$</li><li>C $0\choose n$+C $1\choose n$+$\dots$+C $n\choose n$&#x3D;$2^n$，解释：即从n个数中选出任意多个数的方案数，即每个数都有选或不选，即$2^n$</li></ol><hr><h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="公式组合游戏ICG"><a href="#公式组合游戏ICG" class="headerlink" title="公式组合游戏ICG"></a>公式组合游戏ICG</h3><ol><li>有两名玩家组成且交替行动</li><li>游戏进程中的任意时刻，可执行行动与哪个玩家无关，即每个玩家可执行操作都相同</li><li>不能行动的玩家判输</li></ol><h3 id="规律板子"><a href="#规律板子" class="headerlink" title="规律板子"></a>规律板子</h3><ol><li>必败状态和必胜状态</li><li>S&#x3D;$a_1\land a_2\dots\land a_n$&#x3D;&#x3D;0时，若此时从$a_i$中拿走任意数量，都会使S!&#x3D;0，使下一玩家处于必胜状态</li><li>S&#x3D;$a_1\land a_2\dots\land a_n$!&#x3D;0时，若此时从$a_i$中拿走任意数量，都会使S&#x3D;&#x3D;0，使下一玩家处于必败状态</li></ol><h3 id="Sg函数和Mex运算"><a href="#Sg函数和Mex运算" class="headerlink" title="Sg函数和Mex运算"></a>Sg函数和Mex运算</h3><ol><li>Mex运算：对于非负整数集合，找出该集合中最小的不存在该集合的自然数</li><li>Sg函数：若当前状态可以到y1,y2….yn状态，则sg(x)&#x3D;mex{sg(y1),sg(y2)…,sg(yn)}，一般采用有向图+记忆化搜索做题</li><li>Sg(x)&#x3D;&#x3D;0，先手必败，反之先手必胜</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2022/12/05/9770.html"/>
      <url>/2022/12/05/9770.html</url>
      
        <content type="html"><![CDATA[<h1 id="单源最短路算法"><a href="#单源最短路算法" class="headerlink" title="单源最短路算法"></a>单源最短路算法</h1><h2 id="松弛方程：dis-j-x3D-min-dis-j-dis-k-d-k-j"><a href="#松弛方程：dis-j-x3D-min-dis-j-dis-k-d-k-j" class="headerlink" title="松弛方程：dis[j]&#x3D;min(dis[j],dis[k]+d[k][j])"></a>松弛方程：dis[j]&#x3D;min(dis[j],dis[k]+d[k][j])</h2><h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><h3 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h3><ol><li>找到距离源点最近的点且不在集合中</li><li>该点加入集合</li><li>用该点更新其他点到源点的距离</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>使用小根堆优化1过程</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>堆中可能会存在多个相同点，需要bj数组标记已经确定距离的点</li></ol><h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman_ford"></a>bellman_ford</h2><h3 id="思想：-1"><a href="#思想：-1" class="headerlink" title="思想："></a>思想：</h3><ol><li>循环n-1轮</li><li>每轮都进行松弛所有边</li></ol><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ol><li>spfa算法，只有本轮被更新的点，才有可能引起下一轮松弛操作，因此使用队列维护更新点的集合。</li></ol><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>由于每轮至少松弛一条边，所以至多需要n-1轮，使用队列进行优化时，一样需要标记数组判断当前队列中该元素是否在队列中，以此判断是否加入队列。</li></ol><h3 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h3><ol><li>使用cnt数组记录当前点到源点的边数。</li></ol><h1 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="思想：-2"><a href="#思想：-2" class="headerlink" title="思想："></a>思想：</h3><ol><li>根据动态规划思想，枚举路径所有可能中间节点</li><li>3重循环枚举起点，终点，以此得到所有点到其他点的最短距离</li></ol><h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><h2 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ol><li>类似dijkstra算法，这里的dis表示集合外的点到集合的距离</li><li>因此更新距离时用的是dis[j]&#x3D;min(dis[j],d[k][j])</li></ol><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><ol><li>使用小根堆查找最小距离</li></ol><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><ol><li>存储所有边</li><li>将所有边按从小到大排序</li><li>使用并查集，将n-1条边合并</li></ol><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><ol><li>枚举所有点</li><li>使用dfs递归给该节点子孙上色(1或2)，如果有子孙颜色矛盾，则一路返回，即该图不是二分图。</li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h3><ol><li>二分图最大匹配：在图中，任意两条边都没有公共节点，则为一组最大匹配。</li><li>交替路：从一个未匹配点出发，以此经过非匹配边，匹配边…，形成的路径叫交替路。</li><li>增广路：从一个未匹配点出发，走交替路，若能到达另一个未匹配点，则称这条路为增广路。</li></ol><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><ol><li>不停寻找增广路来增加匹配边，找不到增广路时，即达到最大匹配。</li><li>使用bj数组记录当前各点欲匹配对象，match数组记录已匹配对象，采用曲线救国方式获取当前对象。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/12/04/1106.html"/>
      <url>/2022/12/04/1106.html</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>使用栈来存储单调序列  </li><li>一般单调栈加二分较常见</li></ol><hr><h2 id="单调队列（滑动窗口）"><a href="#单调队列（滑动窗口）" class="headerlink" title="单调队列（滑动窗口）"></a>单调队列（滑动窗口）</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><ol><li>找窗口最小值：当前元素比队尾元素更小时，队尾元素靠前并且还大，没有存在意义，当去除，由此队列是单调上升的，队头最小。</li><li>找窗口最大值：当前元素比队尾元素更大时，队尾元素靠前并且还更小，没有存在意义，当去除，由此队列是单调下降的，队头最大。</li></ol><hr><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><ol><li>构造next数组，存储当前字符在匹配的字符串前缀中最后出现的位置。</li><li>匹配中，不断试探模式串下一个是否与当前匹配，若不匹配则当前位置退一步，即next到前面某个位置继续比较。</li></ol><hr><h2 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h2><h3 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h3><ol><li>son[节点编号][所有子节点]  </li><li>分配编号采用链表形式，使用idx变量赋值编号</li></ol><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><pre><code>void insert(string s)&#123;    int now=0;    for(int i=0;i&lt;s.size();i++)&#123;        if(son[now][s[i]-&#39;a&#39;]==0)&#123;            son[now][s[i]-&#39;a&#39;]=++idx;        &#125;        now=son[now][s[i]-&#39;a&#39;];    &#125;    cnt[now]++;&#125;int query(string s)&#123;    int now=0;    for(int i=0;i&lt;s.size();i++)&#123;        if(son[now][s[i]-&#39;a&#39;]==0)return 0;        now=son[now][s[i]-&#39;a&#39;];    &#125;    return cnt[now];&#125;</code></pre><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="理解-4"><a href="#理解-4" class="headerlink" title="理解"></a>理解</h3><ol><li>初始化fa[i]&#x3D;i  </li><li>Find(int x)查找x的祖宗节点</li><li>优化：路径压缩，通过查找祖宗节点的过程回溯将所有他的子孙节点的父亲节点均改为他，这样下次查询祖宗只需要向上找一次即可。  </li><li>可以利用Find()维护很多信息</li></ol><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="理解-5"><a href="#理解-5" class="headerlink" title="理解"></a>理解</h3><ol><li>down操作</li></ol><pre><code>void down(int x)&#123;    int t=x;    //找到子节点中最小值    if(x*2&lt;=n&amp;&amp;a[x*2]&lt;a[x])t=2*x;    if(x*2+1&lt;=n&amp;&amp;a[x*2+1]&lt;a[t])t=2*x+1;    if(t!=x)&#123;        swap(a[x],a[t]);        down(t);    &#125;&#125;</code></pre><ol start="2"><li>up操作</li></ol><pre><code>void up(int x)&#123;    while(x/2&amp;&amp;a[x/2]&gt;a[x])&#123;        heap_swap(x/2,x);        x/=2;    &#125;&#125;</code></pre><hr><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ol><li>拉链法：哈希映射到h[]数组上，会存在有多个值映射在同一h[]上，因此在每个h[]下使用链表头插法加入。</li><li>开放寻址法：也称蹲坑法，就是先计算出映射值，从这个映射值开始，向后一直找有没有空位，有就进行添加。(比如你有一个固定常去的坑位上厕所，现在被人占了，那么就向后一直找看有没有没人的坑位，如果到了最后一个还没找到，就从第一个坑位继续找。)(前提坑位够)</li></ol><hr><h2 id="字符串前缀哈希"><a href="#字符串前缀哈希" class="headerlink" title="字符串前缀哈希"></a>字符串前缀哈希</h2><ol><li>利用进制思想，将每个字符串映射为一个无符号长整型，使用进制一般为131或13331可以将哈希冲突降到很低。</li><li>计算字串哈希值，可以通过前缀和a[R]-a[L]*p[R-L+1]得到，等同于数字12345想得到45，可以将12345-123x100得到。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法</title>
      <link href="/2022/12/03/11306.html"/>
      <url>/2022/12/03/11306.html</url>
      
        <content type="html"><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a><font color=red>快排</font></h2><h3 id="快排思想"><a href="#快排思想" class="headerlink" title="快排思想"></a><font color=red>快排思想</font></h3><ol><li>在待排序序列中任意取出一个值，使在它左边的数都小于等于它，在它右边的数都大于等于它。  </li><li>对所有左侧的序列进行重复的操作，对右边也是一样。  </li><li>递归退出条件：当R&#x3D;&#x3D;L时此时一定有序，return。</li></ol><h3 id="快排板子"><a href="#快排板子" class="headerlink" title="快排板子"></a><font color=purple>快排板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int a[N];void speed_sort(int L,int R)&#123;    if(L&gt;=R)return;    int x=a[L+R&gt;&gt;1];    int i=L-1,j=R+1;    while(i&lt;j)&#123;        do(i++);while(a[i]&lt;x);        do(j--);while(a[j]&gt;x);        if(i&lt;j)&#123;            swap(a[i],a[j]);        &#125;    &#125;    speed_sort(L,j);    speed_sort(j+1,R);&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    speed_sort(1,n);    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;</code></pre><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color=red>归并排序</font></h2><h3 id="归并排序思想"><a href="#归并排序思想" class="headerlink" title="归并排序思想"></a><font color=puple>归并排序思想</font></h3><ol><li>根据两个有序序列，可以进行合并成一个有序序列。</li><li>先进行递归，递归到两个序列都只有一个元素为止，此时两个序列必定有序，进行合并。</li><li>回溯，用已经有序的左右两个序列合并为一个更大的序列，直到整个序列有序。</li></ol><h3 id="归并排序板子"><a href="#归并排序板子" class="headerlink" title="归并排序板子"></a><font color=red>归并排序板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n;int a[N],b[N];void merge_sort(int L,int R)&#123;    if(L&gt;=R)return;    int M=L+R&gt;&gt;1;    merge_sort(L,M);    merge_sort(M+1,R);    int i=L,j=M+1,k=0;    while(i&lt;=M&amp;&amp;j&lt;=R)&#123;        if(a[i]&lt;a[j])b[++k]=a[i++];        else b[++k]=a[j++];    &#125;    while(i&lt;=M)b[++k]=a[i++];    while(j&lt;=R)b[++k]=a[j++];    for(int i=1,j=L;i&lt;=k;i++,j++)&#123;        a[j]=b[i];    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    merge_sort(1,n);    for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    return 0;&#125;</code></pre><hr><h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a><font color=red>高精度算法</font></h1><h2 id="高精加法"><a href="#高精加法" class="headerlink" title="高精加法"></a><font color=red>高精加法</font></h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过模拟算术加法，每位对应相加，并加上前一位产生的进位</li></ol><h3 id="高精加板子①"><a href="#高精加板子①" class="headerlink" title="高精加板子①"></a><font color=red>高精加板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    //计算    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        c[i]+=a[i]+b[i];        c[i+1]+=c[i]/10;        c[i]=c[i]%10;    &#125;    if(c[len_c+1])len_c++;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精加板子②"><a href="#高精加板子②" class="headerlink" title="高精加板子②"></a><font color=red>高精加板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N=1e5+10;string s1,s2;vector&lt;int&gt;a,b,c;int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    len=s1.size();    len=max(len,int(s2.size()));    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a.push_back(s1[i]-&#39;0&#39;);    for(int i=s2.size()-1;i&gt;=0;i--)b.push_back(s2[i]-&#39;0&#39;);    //计算    int j=0;    for(int i=0;i&lt;len;i++)&#123;        int val=j;        if(i&lt;a.size())val+=a[i];        if(i&lt;b.size())val+=b[i];        j=val/10;        val%=10;        c.push_back(val);    &#125;    if(j)len++,c.push_back(j);    for(int i=len-1;i&gt;=0;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h2 id="高精减法"><a href="#高精减法" class="headerlink" title="高精减法"></a><font color=red>高精减法</font></h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>模拟算术中减法运算，逐位进行相减，不够减则向前一位借一当十使用。</li></ol><h3 id="高精减板子①"><a href="#高精减板子①" class="headerlink" title="高精减板子①"></a><font color=red>高精减板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //判断正负    bool isfu=false;    if(s1.size()==s2.size())&#123;        if(s2&gt;s1)&#123;            isfu=true;            swap(s1,s2);        &#125;    &#125;    else if(s1.size()&lt;s2.size())&#123;        isfu=true;        swap(s1,s2);    &#125;    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        //借一当十        while(a[i]-b[i]&lt;0)a[i+1]--,a[i]+=10;        c[i]=a[i]-b[i];    &#125;    //去除前导0    while(len_c&gt;1&amp;&amp;c[len_c]==0)len_c--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精减板子②"><a href="#高精减板子②" class="headerlink" title="高精减板子②"></a><font color=red>高精减板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;vector&lt;int&gt;a, b, c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    //判断正负    bool isfu = false;    if (s1.size() == s2.size()) &#123;        if (s2 &gt; s1) &#123;            isfu = true;            swap(s1, s2);        &#125;    &#125;    else if (s1.size() &lt; s2.size()) &#123;        isfu = true;        swap(s1, s2);    &#125;    int len = s1.size();    for (int i = s1.size() - 1; i &gt;= 0; i--)a.push_back(s1[i] - &#39;0&#39;);    for (int i = s2.size() - 1; i &gt;= 0; i--)b.push_back(s2[i] - &#39;0&#39;);    int j = 0;    for (int i = 0; i &lt; len; i++) &#123;        j = a[i] - j;        if (i &lt; b.size())j -= b[i];        c.push_back((j + 10) % 10);        if (j &lt; 0)j = 1;        else j = 0;    &#125;    while (len &gt; 1 &amp;&amp; c[len - 1] == 0)len--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for (int i = len - 1; i &gt;= 0; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h2 id="高精乘法"><a href="#高精乘法" class="headerlink" title="高精乘法"></a><font color=red>高精乘法</font></h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>关键c[i+j-1]+&#x3D;a[i]*b[j]</li></ol><h3 id="高精乘板子"><a href="#高精乘板子" class="headerlink" title="高精乘板子"></a><font color=red>高精乘板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;int a[N], b[N], c[N];int len_a, len_b, len_c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = s1.size()-1; i &gt;= 0; i--)a[++len_a] = s1[i] - &#39;0&#39;;    for (int i = s2.size()-1; i &gt;= 0; i--)b[++len_b] = s2[i] - &#39;0&#39;;    len_c = len_a + len_b;    for (int i = 1; i &lt;= len_a; i++) &#123;        for (int j = 1; j &lt;= len_b; j++) &#123;            c[i + j - 1] += a[i] * b[j];            c[i + j] += c[i + j - 1] / 10;            c[i + j - 1] %= 10;        &#125;    &#125;    while (c[len_c] == 0 &amp;&amp; len_c &gt; 1)len_c--;    for (int i = len_c; i &gt;= 1; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h2 id="高精除法（大整数-x2F-小整数）"><a href="#高精除法（大整数-x2F-小整数）" class="headerlink" title="高精除法（大整数&#x2F;小整数）"></a><font color=red>高精除法（大整数&#x2F;小整数）</font></h2><h3 id="高精除板子"><a href="#高精除板子" class="headerlink" title="高精除板子"></a><font color=red>高精除板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1;int b,a[N],c[N];int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;b;    for(int i=0;i&lt;=s1.size()-1;i++)a[++len]=s1[i]-&#39;0&#39;;    //余数    int yu=0;    for(int i=1;i&lt;=len;i++)&#123;        c[i]=(yu*10+a[i])/b;        yu=(yu*10+a[i])%b;    &#125;    int xb=0;    //注意前导0的去除    while(c[xb]==0&amp;&amp;xb&lt;len)xb++;    for(int i=xb;i&lt;=len;i++)cout&lt;&lt;c[i];    cout&lt;&lt;endl&lt;&lt;yu;    return 0;&#125;</code></pre><hr><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a><font color=red>一维前缀和</font></h2><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过计算前缀和，得到前缀和数组，可以计算任意区间的总和值。</li></ol><h3 id="一维前缀和板子"><a href="#一维前缀和板子" class="headerlink" title="一维前缀和板子"></a><font color=red>一维前缀和板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n,a[N],m;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],a[i]+=a[i-1];    while(m--)&#123;        int L,R;        cin&gt;&gt;L&gt;&gt;R;        cout&lt;&lt;a[R]-a[L-1]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a><font color=red>二维前缀和</font></h2><h3 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>前缀和b[i][j]&#x3D;b[i-1][j]+b[i][j-1]+a[i][j]</li><li>区间和b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]</li><li>画图便于理解</li></ol><h3 id="二维前缀和板子"><a href="#二维前缀和板子" class="headerlink" title="二维前缀和板子"></a><font color=red></font>二维前缀和板子</h3><pre><code>#include&lt;iostream&gt;using namespace std;int n,m,q;int a[1003][1003],b[1003][1003];int x1,y1,x2,y2;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;a[i][j];            b[i][j]=b[i-1][j]+b[i][j-1]+a[i][j]-b[i-1][j-1];        &#125;    &#125;    while(q--)&#123;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;        cout&lt;&lt;b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><hr><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a><font color=red>二分</font></h2><h3 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a><font color=puple>二分思想</font></h3><ol><li>对于某个单调序列，查找某个值x在序列中的大致位置（不保证序列中这个值一定存在）通过判断x与序列中点的值，从而确定下次去左半边区间找，还是去右半边区间找。这样最多只需要log(n)次便可找到。</li><li>需要特别注意边界问题，如下两个二分板子</li></ol><h3 id="二分板子"><a href="#二分板子" class="headerlink" title="二分板子"></a><font color=red>二分板子</font></h3><pre><code>int Find_1(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R&gt;&gt;1;        if(a[M]&gt;=x)R=M;        else L=M+1;    &#125;    return L;&#125;int Find_2(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R+1&gt;&gt;1;        if(a[M]&lt;=x)L=M;        else R=M-1;    &#125;    return L;&#125;</code></pre><hr><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a><font color=red>一维差分</font></h2><h3 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过b[L]+&#x3D;c;b[R+1]-&#x3D;c，对差分数组两端点修改，从而再利用前缀和达到对整个区间段修改。</li><li>复杂度降到O(1)</li></ol><h3 id="一维差分板子"><a href="#一维差分板子" class="headerlink" title="一维差分板子"></a><font color=red>一维差分板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n,m;int a[N],b[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    while(m--)&#123;        int L,R,c;        cin&gt;&gt;L&gt;&gt;R&gt;&gt;c;        b[L]+=c;b[R+1]-=c;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        b[i]+=b[i-1];        a[i]+=b[i];        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;</code></pre><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a><font color=red>二维差分</font></h2><h3 id="思想-6"><a href="#思想-6" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>核心：b[x1][y2+1]-&#x3D;c;<br> b[x2+1][y1]-&#x3D;c;<br> b[x1][y1]+&#x3D;c;<br> b[x2+1][y2+1]+&#x3D;c;</li></ol><h3 id="二维差分板子"><a href="#二维差分板子" class="headerlink" title="二维差分板子"></a><font color=red>二维差分板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;int a[1003][1003],b[1003][1003];int n,m,q;int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    while(q--)&#123;        int x1,y1,x2,y2,c;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;        b[x1][y2+1]-=c;        b[x2+1][y1]-=c;        b[x1][y1]+=c;        b[x2+1][y2+1]+=c;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];            a[i][j]+=b[i][j];            cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><hr><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><font color=red>双指针</font></h2><h3 id="思想-7"><a href="#思想-7" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li><p>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )<br> {<br> while (j &lt; i &amp;&amp; check(i, j)) j ++ ;</p><p> &#x2F;&#x2F; 具体问题的逻辑}</p></li></ol><hr><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a><font color=red>二进制</font></h2><h3 id="lowbit求二进制表示中最后一个一的位置"><a href="#lowbit求二进制表示中最后一个一的位置" class="headerlink" title="lowbit求二进制表示中最后一个一的位置"></a><font color=puple>lowbit求二进制表示中最后一个一的位置</font></h3><ol><li>int lowbit(int x){<br> return x&amp;-x;<br>}</li></ol><hr><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><h3 id="思想-8"><a href="#思想-8" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>适用类型：范围很大的一组数据，但是总个数少。</li><li>将原先一组数据映射到新的数组中，根据需要进行排序或去重，可以在排序后通过二分找到原先数组中对应元素在新数组中对应的位置，从而进行后续的操作。</li></ol><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ol><li><font color=puple>排序</font>：sort(num.begin(),num.end());</li><li><font color=puple>去重</font>：num.erase(unique(num.begin(),num.end()),num.end());</li></ol><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
