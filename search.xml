<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基础数论</title>
      <link href="/2022/12/08/26496.html"/>
      <url>/2022/12/08/26496.html</url>
      
        <content type="html"><![CDATA[<h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><ol><li>任何数均能被他的质因子筛去。</li></ol><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><ol><li>任何数均能被他的最小质因子筛去。</li></ol><hr><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h3><ol><li>N&#x3D;${p_1}^{a_1}\times{p_1}^{a_1}\times{p_1}^{a_1}\cdots\times{p_n}^{a_n}$这里$p_i$表示N的质因子，$a_i$表示质因子个数。  </li><li>任何数都可以表示成他的质因数乘积</li></ol><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><ol><li>即质因子的排列组合，有${a_1+1}\times{a_2+1}\times\cdots\times{a_n+1}$种可能，由于是质因子的排列组合，不可能存在有重复答案的排列。</li></ol><h3 id="约数和"><a href="#约数和" class="headerlink" title="约数和"></a>约数和</h3><ol><li>即各排列组合的约数之和，有sum&#x3D;${p_1^0+p_1^1+\cdots+p_1^{a_1}}+{p_2^0+p_2^1+\cdots+p_2^{a_2}}+\cdots$。</li></ol><hr><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><pre><code>int gcd(int a,int b)&#123;    return b==0?a:gcd(b,a%b);&#125;</code></pre><hr><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>phi[n]表示1到n中与n互质的数个数。</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>容斥原理，N&#x3D;${p_1}^{a_1}\times{p_1}^{a_1}\times{p_1}^{a_1}\cdots\times{p_n}^{a_n}$，有N&#x2F;$p_1$个合数，N&#x2F;$p_2$个合数….,这些都要减去，即N-N&#x2F;$p_1$-N&#x2F;$p_2$….，对于N&#x2F;($p_i<em>p_j$)这些数都被重复减去，需要加回来，同理N&#x2F;($p_i</em>p_j*p_k$)需要减去，以此类推。</li><li>答案ans&#x3D;$N\times{(1-1\div p_1)}\times{(1-1\div p_2)}\times\cdots {(1-1\div p_n)}$。</li></ol><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><ol><li>$a^{phi[n]}$%n&#x3D;&#x3D;1，即同余1模n。</li></ol><hr><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><ol><li>11的二进制表示：1011，则$2^{11}$&#x3D;$2^1\times2^2\times2^8$。</li></ol><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><pre><code>void speed_pow(int a,int b,int p)&#123;    long long ans=1,sum=a;    while(b)&#123;        if(b&amp;1)ans=(ans%p*sum)%p;        b&gt;&gt;=1;        sum=sum%p*sum%p;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return;&#125;</code></pre><hr><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h4><ol><li>乘法逆元：$x\times x^{-1}\equiv $ 1(%m)，这里 $x^{-1}$即x的逆元，x与m必须互质才存在逆元。</li><li>证明x与m必须互质：<br>证：假设不互质则有gcd(a,m)&gt;1，令b&#x3D;$a^{-1}$,有a<em>b&#x3D;q</em>m+1;有ab-qm&#x3D;1;因为a,m,有最大公因子大于1，但是右侧1没有大于1的因子，因此与假设矛盾，故x与m必须要互质才存在逆元。</li></ol><h4 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h4><ol><li>对于任意正整数a,b,一定存在整数x,y,使得ax+by&#x3D;gcd(a,b)。</li></ol><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><ol><li>使用欧几里得算法的同时可以通过回溯得到ax+by&#x3D;gcd(a,b)的一组x,y解。</li></ol><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol><li>x $\equiv a_1(mod m_1)$，x $\equiv a_1(mod m_1)$，x $\equiv a_1(mod m_1)$…..，x $\equiv a_n(mod m_n)$，令M&#x3D;m1<em>m2</em>…mn，则有 $M_i$&#x3D;M&#x2F;$m_i$，则x&#x3D;$a_1\times M_1\times M_1^{-1}+a_2\times M_2\times M_2^{-1}+\dots +a_n\times M_n\times M_n^{-1}$。（前提逆元存在，即$m_i$两两互质）</li></ol><h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><ol><li>不保证$m_i$两两互质，若有n个同余式，则每两个可以合并成一个同余式，这样n个同余式最后只会剩一个，这个即为答案。</li></ol><hr><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>使用线性代数初等行变换</li><li>使行列式变成阶梯状</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>枚举每一列</li><li>找到该列绝对值最大的一行</li><li>将该行换到上面</li><li>将下面所有行的这列消成0</li></ol><h3 id="判断解"><a href="#判断解" class="headerlink" title="判断解"></a>判断解</h3><ol><li>完美阶梯状——唯一解</li><li>否则，出现左右等式出现0&#x3D;&#x3D;非0——无解</li><li>否则，——有无穷多组解</li></ol><h3 id="唯一解计算ans"><a href="#唯一解计算ans" class="headerlink" title="唯一解计算ans"></a>唯一解计算ans</h3><ol><li>从最后一行向上把$x_i$解出来</li><li>若当前列不等于0，则需要对应的该列为1的那一行来消除</li><li>最后$x_i{_n}$即为答案</li></ol><hr><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><h3 id="方法一——杨辉三角"><a href="#方法一——杨辉三角" class="headerlink" title="方法一——杨辉三角"></a>方法一——杨辉三角</h3><ol><li>C $i\choose n$&#x3D;C $i\choose n-1$+C $i-1\choose n-1$</li></ol><h3 id="方法2——逆元"><a href="#方法2——逆元" class="headerlink" title="方法2——逆元"></a>方法2——逆元</h3><ol><li>C $b\choose a$&#x3D;$a!\over b!\times {(a-b)}!$&#x3D;$a!\times b!^{-1}\times {(a-b)!^{-1}}$</li><li>前提：mod(n)中n为质数，利用费马小定理+快速幂求逆元</li></ol><h3 id="方法3——卢卡斯定理"><a href="#方法3——卢卡斯定理" class="headerlink" title="方法3——卢卡斯定理"></a>方法3——卢卡斯定理</h3><ol><li>C $b\choose a$&#x3D;C $b\mod p\choose a\mod p$ *C $b&#x2F;p \choose a&#x2F;p$(mod p)</li></ol><hr><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><ol><li>$s_1\cup s_2\dots \cup s_n$&#x3D;$\sum s_i$-$\sum s_i\cap s_j$+$\dots$ $\pm \sum s_i\cap s_j\cap \dots \cap s_r$</li><li>C $0\choose n$+C $1\choose n$+$\dots$+C $n\choose n$&#x3D;$2^n$，解释：即从n个数中选出任意多个数的方案数，即每个数都有选或不选，即$2^n$</li></ol><hr><h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="公式组合游戏ICG"><a href="#公式组合游戏ICG" class="headerlink" title="公式组合游戏ICG"></a>公式组合游戏ICG</h3><ol><li>有两名玩家组成且交替行动</li><li>游戏进程中的任意时刻，可执行行动与哪个玩家无关，即每个玩家可执行操作都相同</li><li>不能行动的玩家判输</li></ol><h3 id="规律板子"><a href="#规律板子" class="headerlink" title="规律板子"></a>规律板子</h3><ol><li>必败状态和必胜状态</li><li>S&#x3D;$a_1\land a_2\dots\land a_n$&#x3D;&#x3D;0时，若此时从$a_i$中拿走任意数量，都会使S!&#x3D;0，使下一玩家处于必胜状态</li><li>S&#x3D;$a_1\land a_2\dots\land a_n$!&#x3D;0时，若此时从$a_i$中拿走任意数量，都会使S&#x3D;&#x3D;0，使下一玩家处于必败状态</li></ol><h3 id="Sg函数和Mex运算"><a href="#Sg函数和Mex运算" class="headerlink" title="Sg函数和Mex运算"></a>Sg函数和Mex运算</h3><ol><li>Mex运算：对于非负整数集合，找出该集合中最小的不存在该集合的自然数</li><li>Sg函数：若当前状态可以到y1,y2….yn状态，则sg(x)&#x3D;mex{sg(y1),sg(y2)…,sg(yn)}，一般采用有向图+记忆化搜索做题</li><li>Sg(x)&#x3D;&#x3D;0，先手必败，反之先手必胜</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2022/12/05/9770.html"/>
      <url>/2022/12/05/9770.html</url>
      
        <content type="html"><![CDATA[<h1 id="单源最短路算法"><a href="#单源最短路算法" class="headerlink" title="单源最短路算法"></a>单源最短路算法</h1><h2 id="松弛方程：dis-j-x3D-min-dis-j-dis-k-d-k-j"><a href="#松弛方程：dis-j-x3D-min-dis-j-dis-k-d-k-j" class="headerlink" title="松弛方程：dis[j]&#x3D;min(dis[j],dis[k]+d[k][j])"></a>松弛方程：dis[j]&#x3D;min(dis[j],dis[k]+d[k][j])</h2><h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><h3 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h3><ol><li>找到距离源点最近的点且不在集合中</li><li>该点加入集合</li><li>用该点更新其他点到源点的距离</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>使用小根堆优化1过程</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>堆中可能会存在多个相同点，需要bj数组标记已经确定距离的点</li></ol><h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman_ford"></a>bellman_ford</h2><h3 id="思想：-1"><a href="#思想：-1" class="headerlink" title="思想："></a>思想：</h3><ol><li>循环n-1轮</li><li>每轮都进行松弛所有边</li></ol><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ol><li>spfa算法，只有本轮被更新的点，才有可能引起下一轮松弛操作，因此使用队列维护更新点的集合。</li></ol><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>由于每轮至少松弛一条边，所以至多需要n-1轮，使用队列进行优化时，一样需要标记数组判断当前队列中该元素是否在队列中，以此判断是否加入队列。</li></ol><h3 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h3><ol><li>使用cnt数组记录当前点到源点的边数。</li></ol><h1 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="思想：-2"><a href="#思想：-2" class="headerlink" title="思想："></a>思想：</h3><ol><li>根据动态规划思想，枚举路径所有可能中间节点</li><li>3重循环枚举起点，终点，以此得到所有点到其他点的最短距离</li></ol><h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><h2 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ol><li>类似dijkstra算法，这里的dis表示集合外的点到集合的距离</li><li>因此更新距离时用的是dis[j]&#x3D;min(dis[j],d[k][j])</li></ol><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><ol><li>使用小根堆查找最小距离</li></ol><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><ol><li>存储所有边</li><li>将所有边按从小到大排序</li><li>使用并查集，将n-1条边合并</li></ol><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><ol><li>枚举所有点</li><li>使用dfs递归给该节点子孙上色(1或2)，如果有子孙颜色矛盾，则一路返回，即该图不是二分图。</li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h3><ol><li>二分图最大匹配：在图中，任意两条边都没有公共节点，则为一组最大匹配。</li><li>交替路：从一个未匹配点出发，以此经过非匹配边，匹配边…，形成的路径叫交替路。</li><li>增广路：从一个未匹配点出发，走交替路，若能到达另一个未匹配点，则称这条路为增广路。</li></ol><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><ol><li>不停寻找增广路来增加匹配边，找不到增广路时，即达到最大匹配。</li><li>使用bj数组记录当前各点欲匹配对象，match数组记录已匹配对象，采用曲线救国方式获取当前对象。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/12/04/1106.html"/>
      <url>/2022/12/04/1106.html</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>使用栈来存储单调序列  </li><li>一般单调栈加二分较常见</li></ol><hr><h2 id="单调队列（滑动窗口）"><a href="#单调队列（滑动窗口）" class="headerlink" title="单调队列（滑动窗口）"></a>单调队列（滑动窗口）</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><ol><li>找窗口最小值：当前元素比队尾元素更小时，队尾元素靠前并且还大，没有存在意义，当去除，由此队列是单调上升的，队头最小。</li><li>找窗口最大值：当前元素比队尾元素更大时，队尾元素靠前并且还更小，没有存在意义，当去除，由此队列是单调下降的，队头最大。</li></ol><hr><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><ol><li>构造next数组，存储当前字符在匹配的字符串前缀中最后出现的位置。</li><li>匹配中，不断试探模式串下一个是否与当前匹配，若不匹配则当前位置退一步，即next到前面某个位置继续比较。</li></ol><hr><h2 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h2><h3 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h3><ol><li>son[节点编号][所有子节点]  </li><li>分配编号采用链表形式，使用idx变量赋值编号</li></ol><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><pre><code>void insert(string s)&#123;    int now=0;    for(int i=0;i&lt;s.size();i++)&#123;        if(son[now][s[i]-&#39;a&#39;]==0)&#123;            son[now][s[i]-&#39;a&#39;]=++idx;        &#125;        now=son[now][s[i]-&#39;a&#39;];    &#125;    cnt[now]++;&#125;int query(string s)&#123;    int now=0;    for(int i=0;i&lt;s.size();i++)&#123;        if(son[now][s[i]-&#39;a&#39;]==0)return 0;        now=son[now][s[i]-&#39;a&#39;];    &#125;    return cnt[now];&#125;</code></pre><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="理解-4"><a href="#理解-4" class="headerlink" title="理解"></a>理解</h3><ol><li>初始化fa[i]&#x3D;i  </li><li>Find(int x)查找x的祖宗节点</li><li>优化：路径压缩，通过查找祖宗节点的过程回溯将所有他的子孙节点的父亲节点均改为他，这样下次查询祖宗只需要向上找一次即可。  </li><li>可以利用Find()维护很多信息</li></ol><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="理解-5"><a href="#理解-5" class="headerlink" title="理解"></a>理解</h3><ol><li>down操作</li></ol><pre><code>void down(int x)&#123;    int t=x;    //找到子节点中最小值    if(x*2&lt;=n&amp;&amp;a[x*2]&lt;a[x])t=2*x;    if(x*2+1&lt;=n&amp;&amp;a[x*2+1]&lt;a[t])t=2*x+1;    if(t!=x)&#123;        swap(a[x],a[t]);        down(t);    &#125;&#125;</code></pre><ol start="2"><li>up操作</li></ol><pre><code>void up(int x)&#123;    while(x/2&amp;&amp;a[x/2]&gt;a[x])&#123;        heap_swap(x/2,x);        x/=2;    &#125;&#125;</code></pre><hr><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ol><li>拉链法：哈希映射到h[]数组上，会存在有多个值映射在同一h[]上，因此在每个h[]下使用链表头插法加入。</li><li>开放寻址法：也称蹲坑法，就是先计算出映射值，从这个映射值开始，向后一直找有没有空位，有就进行添加。(比如你有一个固定常去的坑位上厕所，现在被人占了，那么就向后一直找看有没有没人的坑位，如果到了最后一个还没找到，就从第一个坑位继续找。)(前提坑位够)</li></ol><hr><h2 id="字符串前缀哈希"><a href="#字符串前缀哈希" class="headerlink" title="字符串前缀哈希"></a>字符串前缀哈希</h2><ol><li>利用进制思想，将每个字符串映射为一个无符号长整型，使用进制一般为131或13331可以将哈希冲突降到很低。</li><li>计算字串哈希值，可以通过前缀和a[R]-a[L]*p[R-L+1]得到，等同于数字12345想得到45，可以将12345-123x100得到。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法</title>
      <link href="/2022/12/03/11306.html"/>
      <url>/2022/12/03/11306.html</url>
      
        <content type="html"><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a><font color=red>快排</font></h2><h3 id="快排思想"><a href="#快排思想" class="headerlink" title="快排思想"></a><font color=red>快排思想</font></h3><ol><li>在待排序序列中任意取出一个值，使在它左边的数都小于等于它，在它右边的数都大于等于它。  </li><li>对所有左侧的序列进行重复的操作，对右边也是一样。  </li><li>递归退出条件：当R&#x3D;&#x3D;L时此时一定有序，return。</li></ol><h3 id="快排板子"><a href="#快排板子" class="headerlink" title="快排板子"></a><font color=purple>快排板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int a[N];void speed_sort(int L,int R)&#123;    if(L&gt;=R)return;    int x=a[L+R&gt;&gt;1];    int i=L-1,j=R+1;    while(i&lt;j)&#123;        do(i++);while(a[i]&lt;x);        do(j--);while(a[j]&gt;x);        if(i&lt;j)&#123;            swap(a[i],a[j]);        &#125;    &#125;    speed_sort(L,j);    speed_sort(j+1,R);&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    speed_sort(1,n);    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;</code></pre><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color=red>归并排序</font></h2><h3 id="归并排序思想"><a href="#归并排序思想" class="headerlink" title="归并排序思想"></a><font color=puple>归并排序思想</font></h3><ol><li>根据两个有序序列，可以进行合并成一个有序序列。</li><li>先进行递归，递归到两个序列都只有一个元素为止，此时两个序列必定有序，进行合并。</li><li>回溯，用已经有序的左右两个序列合并为一个更大的序列，直到整个序列有序。</li></ol><h3 id="归并排序板子"><a href="#归并排序板子" class="headerlink" title="归并排序板子"></a><font color=red>归并排序板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n;int a[N],b[N];void merge_sort(int L,int R)&#123;    if(L&gt;=R)return;    int M=L+R&gt;&gt;1;    merge_sort(L,M);    merge_sort(M+1,R);    int i=L,j=M+1,k=0;    while(i&lt;=M&amp;&amp;j&lt;=R)&#123;        if(a[i]&lt;a[j])b[++k]=a[i++];        else b[++k]=a[j++];    &#125;    while(i&lt;=M)b[++k]=a[i++];    while(j&lt;=R)b[++k]=a[j++];    for(int i=1,j=L;i&lt;=k;i++,j++)&#123;        a[j]=b[i];    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    merge_sort(1,n);    for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    return 0;&#125;</code></pre><hr><h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a><font color=red>高精度算法</font></h1><h2 id="高精加法"><a href="#高精加法" class="headerlink" title="高精加法"></a><font color=red>高精加法</font></h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过模拟算术加法，每位对应相加，并加上前一位产生的进位</li></ol><h3 id="高精加板子①"><a href="#高精加板子①" class="headerlink" title="高精加板子①"></a><font color=red>高精加板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    //计算    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        c[i]+=a[i]+b[i];        c[i+1]+=c[i]/10;        c[i]=c[i]%10;    &#125;    if(c[len_c+1])len_c++;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精加板子②"><a href="#高精加板子②" class="headerlink" title="高精加板子②"></a><font color=red>高精加板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N=1e5+10;string s1,s2;vector&lt;int&gt;a,b,c;int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    len=s1.size();    len=max(len,int(s2.size()));    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a.push_back(s1[i]-&#39;0&#39;);    for(int i=s2.size()-1;i&gt;=0;i--)b.push_back(s2[i]-&#39;0&#39;);    //计算    int j=0;    for(int i=0;i&lt;len;i++)&#123;        int val=j;        if(i&lt;a.size())val+=a[i];        if(i&lt;b.size())val+=b[i];        j=val/10;        val%=10;        c.push_back(val);    &#125;    if(j)len++,c.push_back(j);    for(int i=len-1;i&gt;=0;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h2 id="高精减法"><a href="#高精减法" class="headerlink" title="高精减法"></a><font color=red>高精减法</font></h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>模拟算术中减法运算，逐位进行相减，不够减则向前一位借一当十使用。</li></ol><h3 id="高精减板子①"><a href="#高精减板子①" class="headerlink" title="高精减板子①"></a><font color=red>高精减板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //判断正负    bool isfu=false;    if(s1.size()==s2.size())&#123;        if(s2&gt;s1)&#123;            isfu=true;            swap(s1,s2);        &#125;    &#125;    else if(s1.size()&lt;s2.size())&#123;        isfu=true;        swap(s1,s2);    &#125;    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        //借一当十        while(a[i]-b[i]&lt;0)a[i+1]--,a[i]+=10;        c[i]=a[i]-b[i];    &#125;    //去除前导0    while(len_c&gt;1&amp;&amp;c[len_c]==0)len_c--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精减板子②"><a href="#高精减板子②" class="headerlink" title="高精减板子②"></a><font color=red>高精减板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;vector&lt;int&gt;a, b, c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    //判断正负    bool isfu = false;    if (s1.size() == s2.size()) &#123;        if (s2 &gt; s1) &#123;            isfu = true;            swap(s1, s2);        &#125;    &#125;    else if (s1.size() &lt; s2.size()) &#123;        isfu = true;        swap(s1, s2);    &#125;    int len = s1.size();    for (int i = s1.size() - 1; i &gt;= 0; i--)a.push_back(s1[i] - &#39;0&#39;);    for (int i = s2.size() - 1; i &gt;= 0; i--)b.push_back(s2[i] - &#39;0&#39;);    int j = 0;    for (int i = 0; i &lt; len; i++) &#123;        j = a[i] - j;        if (i &lt; b.size())j -= b[i];        c.push_back((j + 10) % 10);        if (j &lt; 0)j = 1;        else j = 0;    &#125;    while (len &gt; 1 &amp;&amp; c[len - 1] == 0)len--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for (int i = len - 1; i &gt;= 0; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h2 id="高精乘法"><a href="#高精乘法" class="headerlink" title="高精乘法"></a><font color=red>高精乘法</font></h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>关键c[i+j-1]+&#x3D;a[i]*b[j]</li></ol><h3 id="高精乘板子"><a href="#高精乘板子" class="headerlink" title="高精乘板子"></a><font color=red>高精乘板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;int a[N], b[N], c[N];int len_a, len_b, len_c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = s1.size()-1; i &gt;= 0; i--)a[++len_a] = s1[i] - &#39;0&#39;;    for (int i = s2.size()-1; i &gt;= 0; i--)b[++len_b] = s2[i] - &#39;0&#39;;    len_c = len_a + len_b;    for (int i = 1; i &lt;= len_a; i++) &#123;        for (int j = 1; j &lt;= len_b; j++) &#123;            c[i + j - 1] += a[i] * b[j];            c[i + j] += c[i + j - 1] / 10;            c[i + j - 1] %= 10;        &#125;    &#125;    while (c[len_c] == 0 &amp;&amp; len_c &gt; 1)len_c--;    for (int i = len_c; i &gt;= 1; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h2 id="高精除法（大整数-x2F-小整数）"><a href="#高精除法（大整数-x2F-小整数）" class="headerlink" title="高精除法（大整数&#x2F;小整数）"></a><font color=red>高精除法（大整数&#x2F;小整数）</font></h2><h3 id="高精除板子"><a href="#高精除板子" class="headerlink" title="高精除板子"></a><font color=red>高精除板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1;int b,a[N],c[N];int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;b;    for(int i=0;i&lt;=s1.size()-1;i++)a[++len]=s1[i]-&#39;0&#39;;    //余数    int yu=0;    for(int i=1;i&lt;=len;i++)&#123;        c[i]=(yu*10+a[i])/b;        yu=(yu*10+a[i])%b;    &#125;    int xb=0;    //注意前导0的去除    while(c[xb]==0&amp;&amp;xb&lt;len)xb++;    for(int i=xb;i&lt;=len;i++)cout&lt;&lt;c[i];    cout&lt;&lt;endl&lt;&lt;yu;    return 0;&#125;</code></pre><hr><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a><font color=red>一维前缀和</font></h2><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过计算前缀和，得到前缀和数组，可以计算任意区间的总和值。</li></ol><h3 id="一维前缀和板子"><a href="#一维前缀和板子" class="headerlink" title="一维前缀和板子"></a><font color=red>一维前缀和板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n,a[N],m;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],a[i]+=a[i-1];    while(m--)&#123;        int L,R;        cin&gt;&gt;L&gt;&gt;R;        cout&lt;&lt;a[R]-a[L-1]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a><font color=red>二维前缀和</font></h2><h3 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>前缀和b[i][j]&#x3D;b[i-1][j]+b[i][j-1]+a[i][j]</li><li>区间和b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]</li><li>画图便于理解</li></ol><h3 id="二维前缀和板子"><a href="#二维前缀和板子" class="headerlink" title="二维前缀和板子"></a><font color=red></font>二维前缀和板子</h3><pre><code>#include&lt;iostream&gt;using namespace std;int n,m,q;int a[1003][1003],b[1003][1003];int x1,y1,x2,y2;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;a[i][j];            b[i][j]=b[i-1][j]+b[i][j-1]+a[i][j]-b[i-1][j-1];        &#125;    &#125;    while(q--)&#123;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;        cout&lt;&lt;b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><hr><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a><font color=red>二分</font></h2><h3 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a><font color=puple>二分思想</font></h3><ol><li>对于某个单调序列，查找某个值x在序列中的大致位置（不保证序列中这个值一定存在）通过判断x与序列中点的值，从而确定下次去左半边区间找，还是去右半边区间找。这样最多只需要log(n)次便可找到。</li><li>需要特别注意边界问题，如下两个二分板子</li></ol><h3 id="二分板子"><a href="#二分板子" class="headerlink" title="二分板子"></a><font color=red>二分板子</font></h3><pre><code>int Find_1(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R&gt;&gt;1;        if(a[M]&gt;=x)R=M;        else L=M+1;    &#125;    return L;&#125;int Find_2(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R+1&gt;&gt;1;        if(a[M]&lt;=x)L=M;        else R=M-1;    &#125;    return L;&#125;</code></pre><hr><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a><font color=red>一维差分</font></h2><h3 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过b[L]+&#x3D;c;b[R+1]-&#x3D;c，对差分数组两端点修改，从而再利用前缀和达到对整个区间段修改。</li><li>复杂度降到O(1)</li></ol><h3 id="一维差分板子"><a href="#一维差分板子" class="headerlink" title="一维差分板子"></a><font color=red>一维差分板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n,m;int a[N],b[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    while(m--)&#123;        int L,R,c;        cin&gt;&gt;L&gt;&gt;R&gt;&gt;c;        b[L]+=c;b[R+1]-=c;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        b[i]+=b[i-1];        a[i]+=b[i];        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;</code></pre><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a><font color=red>二维差分</font></h2><h3 id="思想-6"><a href="#思想-6" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>核心：b[x1][y2+1]-&#x3D;c;<br> b[x2+1][y1]-&#x3D;c;<br> b[x1][y1]+&#x3D;c;<br> b[x2+1][y2+1]+&#x3D;c;</li></ol><h3 id="二维差分板子"><a href="#二维差分板子" class="headerlink" title="二维差分板子"></a><font color=red>二维差分板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;int a[1003][1003],b[1003][1003];int n,m,q;int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    while(q--)&#123;        int x1,y1,x2,y2,c;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;        b[x1][y2+1]-=c;        b[x2+1][y1]-=c;        b[x1][y1]+=c;        b[x2+1][y2+1]+=c;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];            a[i][j]+=b[i][j];            cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><hr><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><font color=red>双指针</font></h2><h3 id="思想-7"><a href="#思想-7" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li><p>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )<br> {<br> while (j &lt; i &amp;&amp; check(i, j)) j ++ ;</p><p> &#x2F;&#x2F; 具体问题的逻辑}</p></li></ol><hr><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a><font color=red>二进制</font></h2><h3 id="lowbit求二进制表示中最后一个一的位置"><a href="#lowbit求二进制表示中最后一个一的位置" class="headerlink" title="lowbit求二进制表示中最后一个一的位置"></a><font color=puple>lowbit求二进制表示中最后一个一的位置</font></h3><ol><li>int lowbit(int x){<br> return x&amp;-x;<br>}</li></ol><hr><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><h3 id="思想-8"><a href="#思想-8" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>适用类型：范围很大的一组数据，但是总个数少。</li><li>将原先一组数据映射到新的数组中，根据需要进行排序或去重，可以在排序后通过二分找到原先数组中对应元素在新数组中对应的位置，从而进行后续的操作。</li></ol><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ol><li><font color=puple>排序</font>：sort(num.begin(),num.end());</li><li><font color=puple>去重</font>：num.erase(unique(num.begin(),num.end()),num.end());</li></ol><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
