<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/02/13/28758.html"/>
      <url>/2023/02/13/28758.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="计算机网络在信息时代的作用"><a href="#计算机网络在信息时代的作用" class="headerlink" title="计算机网络在信息时代的作用"></a>计算机网络在信息时代的作用</h2><ul><li>为我们提供浏览信息和发布信息的平台</li><li>为我们提供通信和交流的平台</li><li>为我们提供休闲和娱乐的平台</li><li>为我们提供资源共享的平台</li><li>为我们提供电子商务的平台</li><li>为我们提供远程协作的平台</li><li>为我们提供网上办公的平台</li></ul><h2 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h2><ul><li>是利用通信设备和通信线路将地理上分散的，具有独立功能多个计算机系统按不同的形式连接起来，以功能完善的网络软件和通信协议实现资源共享和信息传递的系统</li></ul><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="按覆盖范围分"><a href="#按覆盖范围分" class="headerlink" title="按覆盖范围分"></a>按覆盖范围分</h3><ul><li>局域网</li><li>城域网</li><li>广域网</li><li>个人区域网</li></ul><h3 id="按网络使用者分"><a href="#按网络使用者分" class="headerlink" title="按网络使用者分"></a>按网络使用者分</h3><ul><li>共用网</li><li>专用网</li></ul><hr><blockquote><p>Tips：网络 ——&gt; 互联网络 ——&gt; 互联网（世界上最大的互联网络）</p></blockquote><hr><h2 id="互联网从功能上划分"><a href="#互联网从功能上划分" class="headerlink" title="互联网从功能上划分"></a>互联网从功能上划分</h2><ul><li>边缘部分：由所有连接在其上的主机组成</li><li>核心部分：起特殊作用的路由器</li></ul><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><blockquote><p>方式演变：两个电话直接连接——&gt; 多个电话互相连接——&gt; 采用交换机连接<br>  建立连接——&gt; 通话——&gt; 释放连接</p></blockquote><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><blockquote><p>姜宝文划分成多个分组即包，添加必要的信息即首部，再发送给分组交换机，最终到达目的计算机，这种分组交换机先存再转发的方式称为存储转发方式<br>两类分组交换机<br>  路由器<br>  二层交换机（以太网交换机）</p></blockquote><h3 id="分组交换的优点"><a href="#分组交换的优点" class="headerlink" title="分组交换的优点"></a>分组交换的优点</h3><ul><li>高效，在分组传输的过程中动态分配传输带宽，对通信链路是逐渐占用的</li><li>灵活，为每一个分组独立选择转发路由</li><li>迅速，以分组为传送单位，不必建立连接就能向其他主机发送分组</li><li>可靠，分布式路由的分组交换机，使网络有很好的生存性</li></ul><h3 id="分猪脚的缺点"><a href="#分猪脚的缺点" class="headerlink" title="分猪脚的缺点"></a>分猪脚的缺点</h3><ul><li>会有网络时延</li><li>分组携带的信息会带来开销（转发分组需要一点时间）</li><li>无法确保端到端的带宽，会造成网络拥塞</li></ul><h2 id="三种交换方式特点"><a href="#三种交换方式特点" class="headerlink" title="三种交换方式特点"></a>三种交换方式特点</h2><ul><li>电路交换：整个报文的比特流连续从源点直达终点</li><li>报文交换：整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点</li><li>分组交换：单个分组传送到相邻节点，存储下来后查找转发表再转发到下一个节点</li></ul><h2 id="计算机网络的主要性能指标"><a href="#计算机网络的主要性能指标" class="headerlink" title="计算机网络的主要性能指标"></a>计算机网络的主要性能指标</h2><ul><li>速率：指数居的传送速率，也叫数据率或比特率，常说的网络速率是指Mb而不是MB（需要除8）</li><li>带宽：指某信号具有的频带宽度（如说话频率在300HZ~3.4KHZ），也指网络通道传送数据的能力，表示在单位时间从网络中某一点到另一点所能通过的“最高数据率”，单位“比特每秒”</li><li>吞吐量：在确定时间段内，能够传输数据的能力<blockquote><p>Tips: 带宽和吞吐量的区别：带宽指最大速率，吞吐量指某时刻速率，例子：带宽比作马路，路有多宽是固定的，吞吐量就是车流量，不能比道路宽，每个时刻的流量可能是不同的。  </p></blockquote></li><li>时延：从网络的一端传送到另一端需要的时间<blockquote><p>Tips 时延的组成部分 ：<br>发送时延：也叫传输时延，指主机或路由器将整个分组发送到通信线路所需的时间<br>传播时延：电磁波在信道中传播一定距离的时间<br>处理时延：主机或路由器需要花时间对分组进行处理<br>排队时延：分组在路由器中，要在输出队列中排队，确定转发接口后，要在输出队列中排队</p></blockquote></li></ul><blockquote><p>Tips: 在高带宽链路中，比特应当跑的快一点（错的），在高速链路中，我们提高的只是发送速率，而在链路中的传播速率是由介质决定的<br>Tips: 光纤的传输速率高，指他的发送速率高，他的传播速率其实比铜还慢</p></blockquote><ul><li>去包率：即分组丢失率，值在一定时间范围内，分组在传输中丢失的分组数量与总的分组数量的比率<blockquote><p>Tips：丢包原因：<br>在传输过程中出现比特级差错<br>分组交换机中队列满了，后面来的分组就会丢弃<br>由于不是电路交换那样，建立连接，因而会有网络拥塞导致分组交换机的队列溢出和分组丢失</p></blockquote></li><li>利用率：<br>信道利用率：信道有百分之几的时间是被利用的<br>网络利用率：指全网络信道利用率加权平均值<blockquote><p>Tips：信道利用率或网络利用率过高会产生很大时延</p></blockquote></li></ul><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><ul><li>含义：计算机网络的层次结构模型与各层协议的集合称为计算机网络的体系结构</li></ul><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><ul><li>计算机网络由多个互连的节点组成，节点之间要不断交换数据和控制信息，每个节点需要遵守约定的规则，这些规则规定了交换的数据的格式和时序，以及在发送或接收时要采取的动作</li></ul><h3 id="网络协议三要素"><a href="#网络协议三要素" class="headerlink" title="网络协议三要素"></a>网络协议三要素</h3><ul><li>语法：数据和控制信息的结构或格式</li><li>语义：各种控制信息的具体含义</li><li>同步：即事件实现的顺序和时间的详细说明</li></ul><h3 id="按层次涉及计算机网络的好处"><a href="#按层次涉及计算机网络的好处" class="headerlink" title="按层次涉及计算机网络的好处"></a>按层次涉及计算机网络的好处</h3><ul><li>各层次之间独立</li><li>灵活性好</li><li>结构上可分隔开</li><li>易于实现和维护</li><li>有利于功能复用</li><li>能促进标准化工作</li></ul><h2 id="几种计算机网络体系结构"><a href="#几种计算机网络体系结构" class="headerlink" title="几种计算机网络体系结构"></a>几种计算机网络体系结构</h2><h3 id="OSIC开放系统互连系统参考模型"><a href="#OSIC开放系统互连系统参考模型" class="headerlink" title="OSIC开放系统互连系统参考模型"></a>OSIC开放系统互连系统参考模型</h3><pre><code>应用层表示层会话层运输层网络层数据链路层物理层</code></pre><h3 id="TCP-x2F-IP体系结构"><a href="#TCP-x2F-IP体系结构" class="headerlink" title="TCP&#x2F;IP体系结构"></a>TCP&#x2F;IP体系结构</h3><pre><code>应用层运输层网际层网络接口层</code></pre><h3 id="原理体系结构"><a href="#原理体系结构" class="headerlink" title="原理体系结构"></a>原理体系结构</h3><pre><code>应用层运输层网络层数据链路层物理层</code></pre><h2 id="原理体系结构每层大致作用"><a href="#原理体系结构每层大致作用" class="headerlink" title="原理体系结构每层大致作用"></a>原理体系结构每层大致作用</h2><ul><li>物理层：在传输媒体上传输比特流，需考虑传输媒体的类型</li><li>数据链路层：将分组从链路一端送到另一端（相邻两个节点间的链路），传送以帧为单位的数据</li><li>网络层：即网际层，负责为分组交换网上不同主机提供通信服务，将运输层的报文段或用户数据报封装为包或分组传送，也叫数据报，中间需要选择合适的路由传送</li><li>运输层：即传输层，是向两台主机中进程之间的通信提供的数据传输服务<blockquote><p>Tips：两个重要的运输层协议<br>传输控制协议（TCP）：面向连接，可靠的数据传输服务，传输单位是报文段<br>用户数据报协议（UDP）：面向无连接，尽最大努力的数据传输服务，传输单位是用户数据报</p></blockquote></li><li>应用层：是通过应用进程间的交互来完成特定的网络应用<blockquote><p>Tips：应用层交互的数据单元为报文</p></blockquote></li></ul><hr><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="物理层需要考虑的问题"><a href="#物理层需要考虑的问题" class="headerlink" title="物理层需要考虑的问题"></a>物理层需要考虑的问题</h2><ul><li>传输媒体的类型</li><li>位的表示，即如何编码</li><li>数据率，规定每秒发送的比特数（发送方和接收方应保持相同）</li><li>位同步，发送方的时钟与接收方的时钟要保持一致</li><li>链路配置<blockquote><p>点到点配置中，两个设备通过一条专用链路连接<br>多点配置中，多设备共享一条链路</p></blockquote></li><li>物理拓扑结构：网络的拓扑结构</li><li>传输方式，串行与并行传输</li><li>与传输媒体的接口类型</li></ul><h2 id="两种信号"><a href="#两种信号" class="headerlink" title="两种信号"></a>两种信号</h2><ul><li>模拟信号（连续信号）：信息的参数的取值是连续的</li><li>数字信号（离散信号）：消息的参数的取值是离散的<blockquote><p>Tips:<br>数字数据经过编码成数字信号<br>数字数据经过调制成模拟信号</p></blockquote></li></ul><h2 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h2><ul><li>归零制，正脉冲代表1，负脉冲代表0</li><li>不归零制，正点平代表1，负电平代表0</li><li>曼彻斯特编码，位周期中心的上跳变代表0，下跳变代表1</li><li>查分曼彻斯特编码，每一位中心都有跳变，位开始边界有跳变代表0，没有代表1</li></ul><h2 id="基本调制方式"><a href="#基本调制方式" class="headerlink" title="基本调制方式"></a>基本调制方式</h2><blockquote><p>矩形脉冲波形的数字信号包含从直流开始的低频分量，称为基带信号，需要经过调制，才可以在模拟信道传输</p></blockquote><ul><li>带通调制，使用载波调制（调幅，调频，调相）</li><li>正交振幅调制</li></ul><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><blockquote><p>码元是承载信息的基本信号单位，一个码元能承载信息量的多少，由码元信号能表示的数据有限状态个数决定的<br>未提高信息的传输速率，我们总希望一定时间传输更多的码元，但实际上，码元传输率越高，信道传输距离越远，噪声干扰越大，在信道输出端的波形失真越严重</p></blockquote><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><blockquote><p>理想低通信道的最高码元传输速率 &#x3D; 2W（波特）W为信道带宽<br>Tips：要提高信息传输速率，就要让每个码元携带更多个比特的信息量，但采用多元制并不能无限提高信息传输速率，信息传输速率还局限于信噪比</p></blockquote><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><blockquote><p>C &#x3D; W log $_2$(1+S&#x2F;N)（bit&#x2F;s） S为信道内所传送信号的平均功率，N为信道内的高斯噪声功率</p></blockquote><blockquote><p>异步传输与同步传输是采用两种不同的同步传输方式传输<br>  异步：以字节为独立的传输单位，字节内实现同步<br>  同步：以比特流为单位，直接实现同步</p></blockquote><h2 id="光纤的特点"><a href="#光纤的特点" class="headerlink" title="光纤的特点"></a>光纤的特点</h2><ul><li>通信容量非常大</li><li>传输损耗小，远距离传输更经济</li><li>无串音干扰，保密性好</li><li>抗雷电和电磁干扰好</li><li>体积小，重量轻</li></ul><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><blockquote><p>当网络传输媒体的传输容量大于多条单一信道的总通信量时，利用信道复用技术在一条物理线路建立多条通信信道来充分利用传输媒体的带宽</p></blockquote><h2 id="复用技术"><a href="#复用技术" class="headerlink" title="复用技术"></a>复用技术</h2><ul><li>频分复用：就是将传输线路的频带资源划分成多个子频带，形成多个子信道，要求频带宽度大于各个子信道频带宽度之和</li><li>时分复用：将传输线路的宽带资源按时间轮流分配给不同用户，每个用户只在分配的时间里才可以使用线路传输数据，时分复用的用户在每一个TDM帧（时分复用帧）中占固定信号的时隙</li><li>统计时分复用：改进的时分复用，使用（STDM帧）按需动态分配时隙</li><li>波分复用：即光的频分复用</li><li>码分复用：也叫码分多址，每一个用户可在同样的时间使用同样的频带通信，由于各个用户使用特殊挑选的不同码型，因此各用户之间不会造成干扰</li></ul><blockquote><p>Tips：两类扩频通路<br>  直接序列：如码片序列，将每一位bit0或1分成m个短的时隙，称为码片，则发送速率会翻m倍，频带宽度会翻m倍，不同的发送站台的码片序列不仅要互不相同，而且要相互正交，即内积为0<br>  跳频</p></blockquote><h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><ul><li>将用户设备连接到ISP边缘路由器的物理链路及相关设备的集合称为接入网</li></ul><blockquote><p>目前的接入技术<br>  电话网拨号介入<br>  数字用户线接入<br>  光纤同轴混合网线接入<br>  光纤接入<br>  以太网接入<br>  无线接入（基于IEEE802.11技术的无线局域网，也叫wi-fi）和（蜂窝移动通信系统接入，也叫移动通信）</p></blockquote><hr><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h2><blockquote><p>有一条物理线路，还必须有一些通信协议来控制数据传输，现在常用的是网络适配器实现协议</p></blockquote><blockquote><p>Tips：点对点的数据链路层通信步骤：<br>  节点A的数据链路层把网络层交下来IP数据报添加首部和尾部封装成帧<br>  节点A把封装好的帧发送到节点B的数据链路层<br>  若节点B的数据链路层收到的帧无差错，则节点B从收到帧中提取出IP数据报上交给上面的网络层</p></blockquote><h2 id="帧定界"><a href="#帧定界" class="headerlink" title="帧定界"></a>帧定界</h2><ul><li>数据链路层为IP数据报添加首部和尾部后，封装成一个完整的帧，因此数据链路层必须正确识别每个帧的开始和结束，即帧定界</li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><ul><li>发送的数据中不能出现帧定界符，及对上层交给的数据没有任何限制</li><li>字节填充或字符填充，即添加转义字符标记帧定界符（面向字符的链路）</li><li>帧定界采用某个特殊的比特组合（面向比特的链路）</li></ul><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><ul><li>利用差错检测码<blockquote><p>如：<br>需要发送数据D，差错检测码为EDC&#x3D;f$(D)$，判断接受数据D$^{’}$，和接收到的EDC$^{’}$是否等于$f(D^{’})$</p></blockquote></li><li>循环冗余检验（CRC）：通常在帧尾部设置一个差错检验字段<blockquote><p>例如：<br>D&#x3D;101001，G&#x3D;1101（协商得来），计算D$^{’}$&#x3D;101001000,R（余数）&#x3D;D$^{’}$ mod G&#x3D;001，将R加到D$^{’}$，得到D$^{’}$&#x3D;101001001，最终只需要判断D$^{’}$ mod R是否等于0即可</p></blockquote></li></ul><blockquote><p>可靠传输<br>  及发送端发送什么，对应的接收端就接受什么</p></blockquote><h2 id="实现可靠传输"><a href="#实现可靠传输" class="headerlink" title="实现可靠传输"></a>实现可靠传输</h2><ul><li>停止等待协议：发送方每发送一个数据，等待接收方发送回应ACK&#x2F;NAK，当数据分组或确认分组丢失时，采用超时重传解决，如果是确认分组丢失，为防止收到重复分组，发送方给每一个分组不同的发送序号，来丢弃重复分组<blockquote><p>停止等待协议的信道利用率：<br>发送分组需要时间$T_{A}$，来回往返需要时间RTT，接收方发送确认分组需要$T_{B}$，则信道的利用率为U&#x3D;$T_{A} &#x2F; (T_{A}+T_{B}+RTT)$</p></blockquote></li><li>回退N帧协议：又叫滑动窗口协议，是在流水线（即发送方可连续发送多个分组）传输的基础上，利用发送窗口来限制发送方连续发送分组的个数，是一种ARQ协议<blockquote><p>原理：是允许发送方已发送但还没有收到确认的分组序号的范围，窗口大小就是发送方已发送但还没有收到确认的最大分组数</p></blockquote></li><li>选择重传协议：只选择出现差错的分组进行重传，这时接收端窗口大小不再是1，以便收下失序到达但仍然处在接受窗口中的分组，等到所缺分组收齐后再一并送交上层</li></ul><h2 id="点对点协议（PPP）"><a href="#点对点协议（PPP）" class="headerlink" title="点对点协议（PPP）"></a>点对点协议（PPP）</h2><ul><li>用户计算机和ISP进行通话时，通常使用的数据链路层协议</li></ul><h3 id="ppp的特点"><a href="#ppp的特点" class="headerlink" title="ppp的特点"></a>ppp的特点</h3><ul><li>简单，每接受一帧，进行一次CRC，使用PPP的数据链路层向上不提供可靠传输服务，若需要提供可靠传输服务，则有运输层完成</li><li>封装成帧，使用特殊字符作为帧定界符</li><li>透明性，保证透明传输（发送的数据中不含有帧定界符）</li><li>多种网络层协议和多种类型链路，PPP可以在同一条物理链路上同时支持多种网络层协议，并可在多种类型的点对点链路上运行</li><li>接受端能进行差错检测</li><li>可以检测连接状态</li><li>最大传送单元，即接收的分组最大长度（MTU）</li><li>网络层地址协商</li></ul><h3 id="PPP的组成"><a href="#PPP的组成" class="headerlink" title="PPP的组成"></a>PPP的组成</h3><ul><li>一个IP数据报</li><li>一个用来建立，配置和测试数据链路连接的链路控制协议（LCP）</li><li>一套网络控制协议（NCP）</li></ul><h2 id="使用广播的数据链路层"><a href="#使用广播的数据链路层" class="headerlink" title="使用广播的数据链路层"></a>使用广播的数据链路层</h2><blockquote><p>媒体接入控制或多址接入，问题：多个站点发送数据共享信道上信号冲突问题，即如何协调多个发送站点和多个接收站点对一个共享媒体的占用<br>媒体接入控制两大类方法<br>  静态划分信道（频分多址，时分多址，码分多址）<br>  动态接入控制（各站点动态占用信道发送数据）</p></blockquote><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><blockquote><p>局域网的数据链路层<br>  逻辑链路控制子层（LLC）<br>  媒体接入控制子层（MAC）</p></blockquote><blockquote><p>局域网对LLC子层来说是透明的，LLC子层可以为不同类型的网络层协议提供不同类型的数据传输服务</p></blockquote><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><blockquote><p>MAC地址（硬件物理地址）：<br>  当多站点连接在同一个广播信道上时，要实现两站点的通信，每个站点都必须有唯一的标识，即哪一个数据链路层地址（固化在适配器ROM（只读存储器）中的地址）</p></blockquote><blockquote><p>Tips：适配器具有过滤功能<br>  从网络上每收到一个MAC帧，就先用硬件检查MAC帧中的目的地址，是不是发往本站<br>  发往本站：<br>  单播：收到的MAC帧与本站的相同<br>  广播：发送给局域网上所有站点的帧<br>  多播：发送给本局域网上一部分站点的帧</p></blockquote><h2 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h2><h3 id="以太网采取的两种措施"><a href="#以太网采取的两种措施" class="headerlink" title="以太网采取的两种措施"></a>以太网采取的两种措施</h3><ul><li>采用较灵活的无连接工作方式，即不建立连接，发送的数据帧不编号，也不要求对方发回确认帧，以太网提供的服务是不可靠的交付，是尽最大努力的交付</li><li>采用基带传输，发送的数据使用曼彻斯特编码</li></ul><h3 id="媒体接入控制协议"><a href="#媒体接入控制协议" class="headerlink" title="媒体接入控制协议"></a>媒体接入控制协议</h3><ul><li>解决同一时间只允许一个站点发送数据的问题</li><li>载波监听多址接入&#x2F;冲突检测协议（CSMA&#x2F;CD）<blockquote><p>协议要点<br>多址接入，许多站点以多址接入的方式连接在一根总线上<br>载波监听，即“发送前先监听”，即在发送前，用电子技术检测总线上有没有其他站点发送数据信号<br>冲突检测，即“边发送边监听”，也叫碰撞检测，一旦发现总线上出现冲突，适配器就要立即停止发送，等待一段随机时间再发送</p></blockquote></li></ul><blockquote><p>争用期：<br>  以太网的端到端（最远的）的往返时间为2t，又叫冲突窗口，站点发完数据，需经过一个争用期才可以肯定没有发生冲突</p></blockquote><h3 id="截断二进制退避算法"><a href="#截断二进制退避算法" class="headerlink" title="截断二进制退避算法"></a>截断二进制退避算法</h3><ul><li>发生冲突后，推迟一个随机时间，若还冲突，推迟时间延长一倍，为保证所有站点在发送完一帧之前能够检测是否发生了冲突，帧的发送时延不能小于两倍的网络最大传播时延，即一个争用期，因此，以太网规定最短有效帧长度为64字节</li></ul><h2 id="CSMA-x2F-CD-协议的要点"><a href="#CSMA-x2F-CD-协议的要点" class="headerlink" title="CSMA&#x2F;CD 协议的要点"></a>CSMA&#x2F;CD 协议的要点</h2><ul><li>适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存，准备发送</li><li>若适配器检测到信道空闲96比特时间，就发送这个帧，若检测到信道繁忙，则继续监测等待信道转变为空闲96比特时间，然后发送该帧</li><li>在发送过程中一直监测信道，若未检测到信道冲突，则发送完毕，否则，中转发送，并发送人工干扰信号强化冲突</li><li>中止发送后，适配器执行退避算法，随机等待r倍512比特时间，继续执行第二步</li></ul><h2 id="共享式以太网的信道利用率"><a href="#共享式以太网的信道利用率" class="headerlink" title="共享式以太网的信道利用率"></a>共享式以太网的信道利用率</h2><blockquote><p>成功发送一个帧需要占用信道的时间是$T_0$+t，$T_0$为发送需要时间，t为单程最远两个端的距离所需时间，即信道利用率$a&#x3D;t&#x2F;T_0$，所以要让a更大</p></blockquote><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>使用集线器的局域网在物理上是一个星形网，但由于集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍像传统以太网一样运行，在逻辑上仍是一个总线网，各站点共享逻辑上的总线，使用的还是CSMA&#x2F;CD协议</li><li>一个集线器有多个接口，很想一个多接口的转发器</li><li>集线器工作在物理层，每个接口仅简单转发比特，不进行冲突检测</li></ul><blockquote><p>以太网的帧格式：<br>目的地址+源地址+类型+数据+CRC<br>数据应在46~1500字节之间，46是由于最短帧长64字节（防止争用期）减去首部和尾部得来</p></blockquote><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层扩展"><a href="#在物理层扩展" class="headerlink" title="在物理层扩展"></a>在物理层扩展</h3><ul><li>利用转发器</li><li>用集线器：由于冲突域，以太网的最大吞吐量会受影响</li><li>用光纤<blockquote><p>都仅仅相当于延长了共享的传输媒体</p></blockquote></li></ul><h3 id="在数据链路层扩展"><a href="#在数据链路层扩展" class="headerlink" title="在数据链路层扩展"></a>在数据链路层扩展</h3><ul><li>使用网桥扩展<blockquote><p>网桥工作在数据链路层，采用存储转发方式，对MAC帧的目的地址进行检查，并确定转发到那个接口或丢弃，是一种数据链路层上的分组交换机<br>两个以太网通过网桥连接后形成一个更大的以太网，原来的每个以太网称为网段</p></blockquote></li></ul><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><h3 id="网桥原理"><a href="#网桥原理" class="headerlink" title="网桥原理"></a>网桥原理</h3><ul><li>网桥依靠转发表来转发帧，转发表也叫MAC地址表，记录每个接口所能到达的各个站点的MAC地址，若收到广播帧时，则向除接收接口外其他所有接口转发，需要注意，网桥的接口在向某网段转发帧时，仍需执行CSMA&#x2F;CD协议</li></ul><h3 id="网桥的好处"><a href="#网桥的好处" class="headerlink" title="网桥的好处"></a>网桥的好处</h3><ul><li>过滤通信量，增大吞吐量，隔离冲突域</li><li>扩大了物理范围</li><li>提高了可靠性，当网络故障时，一般只影响个别网段</li><li>可以互连不同物理层，不同MAC子层和不同速率的以太网</li></ul><h3 id="网桥的不足"><a href="#网桥的不足" class="headerlink" title="网桥的不足"></a>网桥的不足</h3><ul><li>网桥对接收的帧要先存储和查找转发表，再转发，这里存入缓存中再查找，转发前，需要执行CSMA&#x2F;CD协议，因此增加时延</li><li>MAC子层没有流量控制功能，网桥中缓存会溢出</li><li>会因为过多的用户数而传播过多的广播信息产生网络拥塞，即广播风暴</li></ul><h3 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h3><ul><li>“透明”指局域网上的站点不知道所发送的帧要经过哪些网桥，不需人工配置转发表，透明网桥是一种即插即用的设备</li></ul><blockquote><p>透明网桥的自学习算法：<br>透明网桥每收到一个帧，判断其目的MAC地址是否记录过，是则直接转发过去，不是则更新转发表，将其记录进入的接口，再转发除入口接口外的所有接口（要去自己老的MAC地址或有差错的帧要丢弃）</p></blockquote><h2 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h2><ul><li>避免帧在网络中不断兜圈子</li><li>即定期寻找网络中一颗生成树，再将网桥其他不用的接口关闭，下次再寻找时打开，保证网络中不存在环（prim算法，克鲁斯卡尔算法找最小生成树）</li></ul><h2 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h2><ul><li>也叫交换式集线器，二层交换机，局域网交换机，工作在数据链路层</li><li>交换机实质上就是一个多接口的网桥</li></ul><blockquote><p>Tips：<br>用以太网交换机代替集线器连接计算机，由于采用的是分组交换，不需使用CSMA&#x2F;CD协议共享媒体（以太网交换机每个端口都是一个独立的冲突域），因此工作在无冲突的全双工方式下，可以连接更多的计算机，虽然隔离了冲突域，但仍然是一个广播域，若接入很多的计算机，会产生广播风暴</p></blockquote><h2 id="虚拟局域网（VLAN）"><a href="#虚拟局域网（VLAN）" class="headerlink" title="虚拟局域网（VLAN）"></a>虚拟局域网（VLAN）</h2><ul><li>在一个物理局域网上通过逻辑配置来建立多个逻辑上独立的虚拟网络，将连接在交换机上的站点按需划分为多个与物理位置无关的逻辑组</li></ul><h3 id="虚拟局域网的优点"><a href="#虚拟局域网的优点" class="headerlink" title="虚拟局域网的优点"></a>虚拟局域网的优点</h3><ul><li>简化网络管理</li><li>控制广播风暴</li><li>增强网络的安全性</li></ul><h2 id="无线局域网（WLAN）"><a href="#无线局域网（WLAN）" class="headerlink" title="无线局域网（WLAN）"></a>无线局域网（WLAN）</h2><ul><li>有固定基础设施的（如移动的信号基站）</li><li>无固定基础设施的</li></ul><h2 id="载波监听多址接入、冲突避免协议（CSMA-x2F-CA）"><a href="#载波监听多址接入、冲突避免协议（CSMA-x2F-CA）" class="headerlink" title="载波监听多址接入、冲突避免协议（CSMA&#x2F;CA）"></a>载波监听多址接入、冲突避免协议（CSMA&#x2F;CA）</h2><ul><li>帧间间隔<blockquote><p>SIFS：短帧间间隔，是最短的帧间间隔，用来分开属于一次对话的帧<br>DIFS：即DCF帧间间隔，在DCF方式中用来发送数据帧和管理帧</p></blockquote></li></ul><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>分组转发，每个路由器都有一个转发表</li><li>路由选择，网络层必须决定这些分组所采用的路由或路径，路由选择的结果就是供分组转发的转发表<blockquote><p>网络层在逻辑上划分为两个相互作用的部分<br>数据平面（分组转发）<br>控制平面（路由选择）</p></blockquote></li></ul><blockquote><p>互联网设计思路：<br>  网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务</p></blockquote><h3 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h3><ul><li>在网络层提供面向连接服务的计算机网络</li></ul><h4 id="虚电路网络的组成"><a href="#虚电路网络的组成" class="headerlink" title="虚电路网络的组成"></a>虚电路网络的组成</h4><ul><li>源主机和目的主机之间的路径（即一系列链路和路由器）</li><li>VC号，该路径上每段链路的号码</li><li>该路径上每台路由器（虚电路交换机）中的转发表表项<blockquote><p>Tips：<br>分组通过路由器时，路由器会确定VC号的更换，以确定接下来要走哪一条链路，每台路由器转发表包含了输入VC号与输出VC号的对应关系，每建立一个新的虚电路连接，就要将连接项加入到路由器的转发表中，每释放一个虚电路，相应的就要删去该项</p></blockquote></li></ul><h4 id="虚电路通信的三个阶段"><a href="#虚电路通信的三个阶段" class="headerlink" title="虚电路通信的三个阶段"></a>虚电路通信的三个阶段</h4><ul><li>虚电路建立：发送方运输层与网络层联系，指定接收方地址，确定路径，为每个链路分配VC号，网络层在沿该路径的每台路由器的转发表增加一个表项</li><li>数据传递：路由器根据分组首部的VC号查找转发表，更改其分组的VC号并转发</li><li>虚电路释放</li></ul><h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><ul><li>在网络层提供面向无连接服务的计算机网络</li></ul><h3 id="虚电路和数据报网络对比"><a href="#虚电路和数据报网络对比" class="headerlink" title="虚电路和数据报网络对比"></a>虚电路和数据报网络对比</h3><table><thead><tr><th align="center">对比的方面</th><th align="center">虚电路网络</th><th align="center">数据报网络</th></tr></thead><tbody><tr><td align="center">思路</td><td align="center">可靠通信应由网络层保证</td><td align="center">可靠通信应由用户主机的传输层保证</td></tr><tr><td align="center">连接的建立</td><td align="center">必须有</td><td align="center">不需要</td></tr><tr><td align="center">终点的地址</td><td align="center">仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td align="center">每个分组都有终点完整地址</td></tr><tr><td align="center">分组转发</td><td align="center">属于同一条虚电路的分组均按统一路由转发</td><td align="center">每个分组独立选择路由转发</td></tr><tr><td align="center">分组的到达顺序</td><td align="center">总是按发送顺序到达</td><td align="center">可能无序</td></tr></tbody></table><blockquote><p>网际协议（IP，又叫互联网协议）<br>  地址解析协议（ARP）<br>  互联网控制报文协议（ICMP）<br>  互联网组管理协议（IGMP）<br>  ARP——&gt;IP——&gt;ICMP和IGMP（——&gt;被使用）</p></blockquote><h2 id="IP网"><a href="#IP网" class="headerlink" title="IP网"></a>IP网</h2><ul><li>让参加互连的计算机网络使用相同的IP，这样就可以看成一个虚拟互联网络（世界上最大的IP网就是互联网），好处是主机看不到里面互连的各个网络的具体异构细节</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>由32位二进制组成，每8位划分</li></ul><h3 id="IP地址的编址方式"><a href="#IP地址的编址方式" class="headerlink" title="IP地址的编址方式"></a>IP地址的编址方式</h3><blockquote><p>三个历史阶段<br>  分类编址——&gt;划分子网——&gt;无分类编址</p></blockquote><h4 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h4><ul><li>分类编址：IP地址::&#x3D;{&lt;网络号&gt;,&lt;主机号&gt;}</li><li>好处1：IP地址管理局只需要分配网络号</li><li>好处2：路由器仅根据目的主机所连接的网络号来转发</li></ul><blockquote><p>IP地址的分类：<br>  A类：网络号8位，主机号24位，单播地址<br>  B类：网络号16位，主机号16位，单播地址<br>  C类：网络号24位，主机号8位，单播地址<br>  D类：多播地址<br>  E类：多播地址</p></blockquote><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><ul><li>从网络的主机号借用若干位作为子网号，当然主机号也就相应减少了同样位数，即：IP地址::&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</li></ul><h4 id="无分类编址"><a href="#无分类编址" class="headerlink" title="无分类编址"></a>无分类编址</h4><ul><li>无类别域间路由选择，前面是不定长的“网络前缀”，后面部分则用来指明主机，使用与IP地址配合使用的32位地址掩码，也叫子网掩码</li></ul><blockquote><p>由路由器互连起来的每个网络有唯一的网络前缀（即网络号），并用主机号全0的IP地址表示该网络的IP地址</p></blockquote><h3 id="计算地址块最小地址和最大地址"><a href="#计算地址块最小地址和最大地址" class="headerlink" title="计算地址块最小地址和最大地址"></a>计算地址块最小地址和最大地址</h3><blockquote><p>CIDR把网络号都相同的连续IP地址组成一个CIDR地址块<br>地址块 192.199.170.82&#x2F;27，求最小地址块和最大地址块，27表示网络前缀27位，主机号5位，则该地址块有32个IP地址，地址块与网络前缀与运算后得到：192.199.170.64，即为最小地址，后5位全填1，即为最大地址：192.199.170.95</p></blockquote><blockquote><p>主机地址块数量比地址块数量少2，即去掉主机地址全0或全1的情况</p></blockquote><h3 id="IP地址的分配"><a href="#IP地址的分配" class="headerlink" title="IP地址的分配"></a>IP地址的分配</h3><ul><li>由路由器互联的每个网络有唯一的网络前缀</li><li>各网络子网掩码可以不同</li><li>连接在同一网络的主机或路由器的IP地址的网络前缀必须与该网络的网络前缀一样</li><li>由于路由器连接多个网络，因此具有两个以上的IP地址，而网桥互连的网段仍然是一个物理网络</li></ul><blockquote><p>例题：<br>  地址块 206.0.68.0&#x2F;22——&gt;206.0.68.0&#x2F;23和206.0.70.0&#x2F;23，划分成两块均等大小的地址块，舍去第23位的用户位来划分出2个（分别取值为0或1）</p></blockquote><h3 id="IP地址和物理地址的关系"><a href="#IP地址和物理地址的关系" class="headerlink" title="IP地址和物理地址的关系"></a>IP地址和物理地址的关系</h3><ul><li>物理地址是数据链路层或物理层使用的地址，而IP地址是网络层及以上各层使用的地址，是一种逻辑地址</li><li>IP数据报被放入数据链路层的MAC帧后，整个IP数据报就成为MAC帧的数据部分，因而在数据链路层看不见数据报的IP地址</li></ul><blockquote><p>IP数据报经过中间任何路由器，他的首部中的源地址和目的地址始终都是源主机的IP和目的主机的IP，在局域网的链路层，只能看见MAC帧，路由器只根据目的IP地址转发IP数据报</p></blockquote><h2 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h2><ul><li>找到已知IP地址的机器的物理地址（ARP）</li></ul><blockquote><p>使用ARP的每一个主机都设置有一个ARP高速缓存，里面有局域网上的各主机和路由器的IP地址到物理地址的映射表</p></blockquote><h3 id="ARP运行步骤"><a href="#ARP运行步骤" class="headerlink" title="ARP运行步骤"></a>ARP运行步骤</h3><blockquote><p>如主机A发往主机B<br>  在A的高速缓存中查看有无B的IP地址，有的话，查出其物理地址并转发，否则，在本局域网广播发送ARP请求分组，该分组直接封装在数据链路层广播帧中，内容为A的IP地址，物理地址，想知道的IP为B的物理地址，当B看到请求分组时，就向主机A发送ARP响应分组（回应自己的物理地址），并记录A的IP地址和物理地址在自己的ARP高速缓存中，以后好方便查找</p></blockquote><blockquote><p>Tips：<br>  虽然ARP请求分组是广播，但ARP响应分组是单播（直达目的）<br>  ARP高速缓存中的每一对映射都设置有生存时间（防止日后会改变物理地址，如更换适配器）<br>  ARP可在局域网实现IP地址冲突检测，只需要在本站广播本主机IP地址，有回复的话则产生了冲突</p></blockquote><h2 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h2><ul><li>首部加数据部分</li><li>首部：固定部分（20字节）+可变部分</li><li>标识字段：每产生一个数据报，计数器加1，此值赋给标识字段，当长度超过MTU时，要进行分片，相同标识的字段的值使分片的各个数据报片在最后目的站点能正确重装成原来的数据报</li><li>标志字段：MF&#x3D;1表示后面还有分片，DF&#x3D;1表示不能分片，若DF&#x3D;1且数据报长度超过MTU则丢弃该数据报，并向源点发一个ICMP（互联网控制报文协议）终点不可达差错报告</li><li>片偏移：较长的分组分片后，某片在原分组的相对位置（相对于数据部分起点），以8字节为偏移单位</li></ul><blockquote><p>Tips：<br>  IP数据报在传送过程中可能被多次分片，但分片的数据仅在目的主机才被重装为原来的数据报</p></blockquote><ul><li>生存时间（TTL）：占8位，因此最大数值位255，每经过一个路由器，TTL就要减少1，为0时，该数据分组要丢弃</li></ul><h2 id="IP数据报的转发"><a href="#IP数据报的转发" class="headerlink" title="IP数据报的转发"></a>IP数据报的转发</h2><ul><li>路由表并不是按目的地址来制作的，而是按目的主机所在网络号来制作的（和其网络地址掩码）</li></ul><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><ul><li>以减少路由表所占用的空间和搜索路由表的时间，一直通过间接交付的方式找到目的网络的路由器，最后直接交付</li></ul><h3 id="混合路由（地址聚合）"><a href="#混合路由（地址聚合）" class="headerlink" title="混合路由（地址聚合）"></a>混合路由（地址聚合）</h3><ul><li>多个路由相同的小的CIDR地址块可以聚合成大的地址块，从而减少路由表项目</li></ul><h2 id="ICMP（互联网控制报文协议）"><a href="#ICMP（互联网控制报文协议）" class="headerlink" title="ICMP（互联网控制报文协议）"></a>ICMP（互联网控制报文协议）</h2><ul><li>ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告，ICMP报文作为IP数据报的数据部分再加上数据报的首部，组成IP数据报发送出去<blockquote><p>ICMP种类<br>ICMP差错报告报文<br>ICMP询问报文</p></blockquote></li></ul><blockquote><p>Tips：<br>  IP数据报的首部校验和只能检验数据报的首部，不检验数据部分，因此不能保证传输的ICMP报文无差错</p></blockquote><h3 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h3><ul><li>终点不可达的报文类型，路由器或主机不能交付数据报时，就向源点发送终点不可达报文</li><li>超时的报文类型，生存时间（TTL）超时或分片重装超时，路由器每收到一个IP数据报时，若目的地址不是自己，则将其TTL减少1，再转发，当TTL减少为0时，要丢弃该数据报并向源点发送超时报文，另外，终点在规定时间不能收到一个数据报的全部数据报片，就会丢弃已接收的全部数据报分片，并发送超时报文</li><li>参数问题类型，当路由器或目的主机收到的数据报的首部字段的值不正确时，则丢弃该数据报，并向源点发送参数问题报文</li><li>路由重定向类型，路由器把路由重定向报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（提供一条更好的路由）</li></ul><h3 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h3><ul><li>回送请求和会送应答：是由一个主机或路由器向一个特定的主机发送的询问，收到报文的主机应将ICMP回送报文原封不动发送回去</li><li>时间戳请求和时间戳应答：用于请某个主机或路由器应答当前的日期和时间，这种报文可以用来进行时钟同步和测量时间</li></ul><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><ul><li>路由选择算法就是计算从某个节点到所有其他节点的最短路程<blockquote><p>路由选择算法<br>静态路由选择（非自适应路由选择）大部分为人工配置每条路由<br>动态路由选择（自适应路由选择）可随网络通信量或拓扑结构自适应的进行调整</p></blockquote></li></ul><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><blockquote><p>互联网采用分层次的路由选择协议的原因<br>  互联网的规模非常大<br>  许多单位不想外部了解自己的网络布局和自己单位采用的路由选择协议，但还希望连接到互联网上<br>Tips：<br>  整个互联网被划分成许多小的自治系统（AS），目前的互联网，一个大的ISP就是一个自治系统<br>  路由选择协议的划分：<br>  ①内部网关协议（IGP）一个自治系统的内部使用的路由选择协议，有RIP和OSPF等<br>  ②外部网关协议（EGP）在不同的自治系统间使用的路由选择协议，有BGP-4等</p></blockquote><ul><li>自治系统之间的路由选择叫域间路由选择</li><li>自治系统之内的路由选择叫域内路由选择</li></ul><h4 id="路由信息协议（RIP）"><a href="#路由信息协议（RIP）" class="headerlink" title="路由信息协议（RIP）"></a>路由信息协议（RIP）</h4><ul><li>也叫距离向量路由选择算法（Bellman-Ford）</li><li>好消息传的快，坏消息传的慢，当网络故障时，需经过较长的时间才能将此信息传送到所有的路由器</li></ul><h4 id="开放式最短路经优先协议（OSPF）"><a href="#开放式最短路经优先协议（OSPF）" class="headerlink" title="开放式最短路经优先协议（OSPF）"></a>开放式最短路经优先协议（OSPF）</h4><ul><li>指使用（Dijkstra）算法寻找最短路</li></ul><h4 id="边界网关协议（BGP）"><a href="#边界网关协议（BGP）" class="headerlink" title="边界网关协议（BGP）"></a>边界网关协议（BGP）</h4><ul><li>只是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非找一条最佳路由，重要的是能根据策略进行路由选择<blockquote><p>每个AS的管理员要选择至少一个路由器作为该AS的“BGP发言人”，BGP发言人在负责在AS间交换路由信息，BGP发言人往往配置在AS边界路由器上</p></blockquote></li></ul><h2 id="路由器的构成"><a href="#路由器的构成" class="headerlink" title="路由器的构成"></a>路由器的构成</h2><ul><li>是具有多个输出，输入端口的专用计算机，主要任务是转发分组</li><li>划分为两部分<blockquote><p>路由选择部分（路由选择处理机为核心部分）<br>分组转发部分（输入端口，输出端口，交换结构）</p></blockquote></li></ul><h2 id="路由器和交换机比较"><a href="#路由器和交换机比较" class="headerlink" title="路由器和交换机比较"></a>路由器和交换机比较</h2><ul><li>路由器：工作在网络层利用网络地址转发分组</li><li>交换机：工作在数据链路层利用物理地址转发分组<blockquote><p>路由器：可以隔离广播风暴<br>交换机：即插即用，交换速度快（路由器不同于交换机，还需要处理第二层和第三层传送上来的帧，因此较慢）</p></blockquote></li></ul><h2 id="专用地址"><a href="#专用地址" class="headerlink" title="专用地址"></a>专用地址</h2><blockquote><p>本地地址：在机构内部互相通信，由机构内部分配IP地址，只能用于和机构内的主机通信，而不能用于互联网上的主机通信</p></blockquote><ul><li>由官方定义的地址块用于专用地址，用于本地地址</li></ul><blockquote><p>本地地址：只在本机构内部有效<br>  全球地址：在全球范围内唯一</p></blockquote><h2 id="虚拟专用网（VPN）"><a href="#虚拟专用网（VPN）" class="headerlink" title="虚拟专用网（VPN）"></a>虚拟专用网（VPN）</h2><ul><li>利用公用的互联网作为各专用网的通信载体<blockquote><p>隧道技术：<br>IP-in-IP隧道技术，讲一个IP数据报直接封装到另一个IP数据报中传输</p></blockquote></li></ul><h3 id="使用隧道技术实现VPN"><a href="#使用隧道技术实现VPN" class="headerlink" title="使用隧道技术实现VPN"></a>使用隧道技术实现VPN</h3><blockquote><p>例如：分散在两个地方的同一机构的A主机，B主机，A要发送数据给B<br>  A中目的地址和源地址均为本地地址——&gt; 利用隧道技术，在封装为源IP地址和目的IP地址均为全球地址——&gt; 到达B处，进行解密并恢复本地地址完成传输</p></blockquote><h3 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h3><ul><li>使大量使用内部专用地址的专用网用户共享少量外部全球地址来访问互联网上的主机和资源</li><li>需要在专用网连接互联网的路由器上运行NAT软件，因此该路由器也叫NAT路由器，至少有一个全球地址</li></ul><h4 id="具体转换方法"><a href="#具体转换方法" class="headerlink" title="具体转换方法"></a>具体转换方法</h4><blockquote><p>例如：专用网中A要连接到互联网中B：<br>  A发送数据给B时，NAT路由器会为主机A分配一个临时的全球地址作为A的源地址，目的地址还是B<br>  B发送数据给A时，NAT路由器会将目的地址换回A的专用地址，源地址还是B<br>  这样完成两边互相发送数据</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数论</title>
      <link href="/2022/12/08/26496.html"/>
      <url>/2022/12/08/26496.html</url>
      
        <content type="html"><![CDATA[<h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><ol><li>任何数均能被他的质因子筛去。</li></ol><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><ol><li>任何数均能被他的最小质因子筛去。</li></ol><hr><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h3><ol><li>N&#x3D;${p_1}^{a_1}\times{p_1}^{a_1}\times{p_1}^{a_1}\cdots\times{p_n}^{a_n}$这里$p_i$表示N的质因子，$a_i$表示质因子个数。  </li><li>任何数都可以表示成他的质因数乘积</li></ol><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><ol><li>即质因子的排列组合，有${a_1+1}\times{a_2+1}\times\cdots\times{a_n+1}$种可能，由于是质因子的排列组合，不可能存在有重复答案的排列。</li></ol><h3 id="约数和"><a href="#约数和" class="headerlink" title="约数和"></a>约数和</h3><ol><li>即各排列组合的约数之和，有sum&#x3D;${p_1^0+p_1^1+\cdots+p_1^{a_1}}+{p_2^0+p_2^1+\cdots+p_2^{a_2}}+\cdots$。</li></ol><hr><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><pre><code>int gcd(int a,int b)&#123;    return b==0?a:gcd(b,a%b);&#125;</code></pre><hr><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>phi[n]表示1到n中与n互质的数个数。</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>容斥原理，N&#x3D;${p_1}^{a_1}\times{p_1}^{a_1}\times{p_1}^{a_1}\cdots\times{p_n}^{a_n}$，有N&#x2F;$p_1$个合数，N&#x2F;$p_2$个合数….,这些都要减去，即N-N&#x2F;$p_1$-N&#x2F;$p_2$….，对于N&#x2F;($p_i<em>p_j$)这些数都被重复减去，需要加回来，同理N&#x2F;($p_i</em>p_j*p_k$)需要减去，以此类推。</li><li>答案ans&#x3D;$N\times{(1-1\div p_1)}\times{(1-1\div p_2)}\times\cdots {(1-1\div p_n)}$。</li></ol><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><ol><li>$a^{phi[n]}$%n&#x3D;&#x3D;1，即同余1模n。</li></ol><hr><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><ol><li>11的二进制表示：1011，则$2^{11}$&#x3D;$2^1\times2^2\times2^8$。</li></ol><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><pre><code>void speed_pow(int a,int b,int p)&#123;    long long ans=1,sum=a;    while(b)&#123;        if(b&amp;1)ans=(ans%p*sum)%p;        b&gt;&gt;=1;        sum=sum%p*sum%p;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return;&#125;</code></pre><hr><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h4><ol><li>乘法逆元：$x\times x^{-1}\equiv $ 1(%m)，这里 $x^{-1}$即x的逆元，x与m必须互质才存在逆元。</li><li>证明x与m必须互质：<br>证：假设不互质则有gcd(a,m)&gt;1，令b&#x3D;$a^{-1}$,有a<em>b&#x3D;q</em>m+1;有ab-qm&#x3D;1;因为a,m,有最大公因子大于1，但是右侧1没有大于1的因子，因此与假设矛盾，故x与m必须要互质才存在逆元。</li></ol><h4 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h4><ol><li>对于任意正整数a,b,一定存在整数x,y,使得ax+by&#x3D;gcd(a,b)。</li></ol><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><ol><li>使用欧几里得算法的同时可以通过回溯得到ax+by&#x3D;gcd(a,b)的一组x,y解。</li></ol><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol><li>x $\equiv a_1(mod m_1)$，x $\equiv a_1(mod m_1)$，x $\equiv a_1(mod m_1)$…..，x $\equiv a_n(mod m_n)$，令M&#x3D;m1<em>m2</em>…mn，则有 $M_i$&#x3D;M&#x2F;$m_i$，则x&#x3D;$a_1\times M_1\times M_1^{-1}+a_2\times M_2\times M_2^{-1}+\dots +a_n\times M_n\times M_n^{-1}$。（前提逆元存在，即$m_i$两两互质）</li></ol><h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><ol><li>不保证$m_i$两两互质，若有n个同余式，则每两个可以合并成一个同余式，这样n个同余式最后只会剩一个，这个即为答案。</li></ol><hr><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>使用线性代数初等行变换</li><li>使行列式变成阶梯状</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>枚举每一列</li><li>找到该列绝对值最大的一行</li><li>将该行换到上面</li><li>将下面所有行的这列消成0</li></ol><h3 id="判断解"><a href="#判断解" class="headerlink" title="判断解"></a>判断解</h3><ol><li>完美阶梯状——唯一解</li><li>否则，出现左右等式出现0&#x3D;&#x3D;非0——无解</li><li>否则，——有无穷多组解</li></ol><h3 id="唯一解计算ans"><a href="#唯一解计算ans" class="headerlink" title="唯一解计算ans"></a>唯一解计算ans</h3><ol><li>从最后一行向上把$x_i$解出来</li><li>若当前列不等于0，则需要对应的该列为1的那一行来消除</li><li>最后$x_i{_n}$即为答案</li></ol><hr><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><h3 id="方法一——杨辉三角"><a href="#方法一——杨辉三角" class="headerlink" title="方法一——杨辉三角"></a>方法一——杨辉三角</h3><ol><li>C $i\choose n$&#x3D;C $i\choose n-1$+C $i-1\choose n-1$</li></ol><h3 id="方法2——逆元"><a href="#方法2——逆元" class="headerlink" title="方法2——逆元"></a>方法2——逆元</h3><ol><li>C $b\choose a$&#x3D;$a!\over b!\times {(a-b)}!$&#x3D;$a!\times b!^{-1}\times {(a-b)!^{-1}}$</li><li>前提：mod(n)中n为质数，利用费马小定理+快速幂求逆元</li></ol><h3 id="方法3——卢卡斯定理"><a href="#方法3——卢卡斯定理" class="headerlink" title="方法3——卢卡斯定理"></a>方法3——卢卡斯定理</h3><ol><li>C $b\choose a$&#x3D;C $b\mod p\choose a\mod p$ *C $b&#x2F;p \choose a&#x2F;p$(mod p)</li></ol><hr><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><ol><li>$s_1\cup s_2\dots \cup s_n$&#x3D;$\sum s_i$-$\sum s_i\cap s_j$+$\dots$ $\pm \sum s_i\cap s_j\cap \dots \cap s_r$</li><li>C $0\choose n$+C $1\choose n$+$\dots$+C $n\choose n$&#x3D;$2^n$，解释：即从n个数中选出任意多个数的方案数，即每个数都有选或不选，即$2^n$</li></ol><hr><h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="公式组合游戏ICG"><a href="#公式组合游戏ICG" class="headerlink" title="公式组合游戏ICG"></a>公式组合游戏ICG</h3><ol><li>有两名玩家组成且交替行动</li><li>游戏进程中的任意时刻，可执行行动与哪个玩家无关，即每个玩家可执行操作都相同</li><li>不能行动的玩家判输</li></ol><h3 id="规律板子"><a href="#规律板子" class="headerlink" title="规律板子"></a>规律板子</h3><ol><li>必败状态和必胜状态</li><li>S&#x3D;$a_1\land a_2\dots\land a_n$&#x3D;&#x3D;0时，若此时从$a_i$中拿走任意数量，都会使S!&#x3D;0，使下一玩家处于必胜状态</li><li>S&#x3D;$a_1\land a_2\dots\land a_n$!&#x3D;0时，若此时从$a_i$中拿走任意数量，都会使S&#x3D;&#x3D;0，使下一玩家处于必败状态</li></ol><h3 id="Sg函数和Mex运算"><a href="#Sg函数和Mex运算" class="headerlink" title="Sg函数和Mex运算"></a>Sg函数和Mex运算</h3><ol><li>Mex运算：对于非负整数集合，找出该集合中最小的不存在该集合的自然数</li><li>Sg函数：若当前状态可以到y1,y2….yn状态，则sg(x)&#x3D;mex{sg(y1),sg(y2)…,sg(yn)}，一般采用有向图+记忆化搜索做题</li><li>Sg(x)&#x3D;&#x3D;0，先手必败，反之先手必胜</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2022/12/05/9770.html"/>
      <url>/2022/12/05/9770.html</url>
      
        <content type="html"><![CDATA[<h1 id="单源最短路算法"><a href="#单源最短路算法" class="headerlink" title="单源最短路算法"></a>单源最短路算法</h1><h2 id="松弛方程：dis-j-x3D-min-dis-j-dis-k-d-k-j"><a href="#松弛方程：dis-j-x3D-min-dis-j-dis-k-d-k-j" class="headerlink" title="松弛方程：dis[j]&#x3D;min(dis[j],dis[k]+d[k][j])"></a>松弛方程：dis[j]&#x3D;min(dis[j],dis[k]+d[k][j])</h2><h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><h3 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h3><ol><li>找到距离源点最近的点且不在集合中</li><li>该点加入集合</li><li>用该点更新其他点到源点的距离</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>使用小根堆优化1过程</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>堆中可能会存在多个相同点，需要bj数组标记已经确定距离的点</li></ol><h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman_ford"></a>bellman_ford</h2><h3 id="思想：-1"><a href="#思想：-1" class="headerlink" title="思想："></a>思想：</h3><ol><li>循环n-1轮</li><li>每轮都进行松弛所有边</li></ol><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ol><li>spfa算法，只有本轮被更新的点，才有可能引起下一轮松弛操作，因此使用队列维护更新点的集合。</li></ol><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>由于每轮至少松弛一条边，所以至多需要n-1轮，使用队列进行优化时，一样需要标记数组判断当前队列中该元素是否在队列中，以此判断是否加入队列。</li></ol><h3 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h3><ol><li>使用cnt数组记录当前点到源点的边数。</li></ol><h1 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="思想：-2"><a href="#思想：-2" class="headerlink" title="思想："></a>思想：</h3><ol><li>根据动态规划思想，枚举路径所有可能中间节点</li><li>3重循环枚举起点，终点，以此得到所有点到其他点的最短距离</li></ol><h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><h2 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ol><li>类似dijkstra算法，这里的dis表示集合外的点到集合的距离</li><li>因此更新距离时用的是dis[j]&#x3D;min(dis[j],d[k][j])</li></ol><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><ol><li>使用小根堆查找最小距离</li></ol><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><ol><li>存储所有边</li><li>将所有边按从小到大排序</li><li>使用并查集，将n-1条边合并</li></ol><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><ol><li>枚举所有点</li><li>使用dfs递归给该节点子孙上色(1或2)，如果有子孙颜色矛盾，则一路返回，即该图不是二分图。</li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h3><ol><li>二分图最大匹配：在图中，任意两条边都没有公共节点，则为一组最大匹配。</li><li>交替路：从一个未匹配点出发，以此经过非匹配边，匹配边…，形成的路径叫交替路。</li><li>增广路：从一个未匹配点出发，走交替路，若能到达另一个未匹配点，则称这条路为增广路。</li></ol><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><ol><li>不停寻找增广路来增加匹配边，找不到增广路时，即达到最大匹配。</li><li>使用bj数组记录当前各点欲匹配对象，match数组记录已匹配对象，采用曲线救国方式获取当前对象。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/12/04/1106.html"/>
      <url>/2022/12/04/1106.html</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>使用栈来存储单调序列  </li><li>一般单调栈加二分较常见</li></ol><hr><h2 id="单调队列（滑动窗口）"><a href="#单调队列（滑动窗口）" class="headerlink" title="单调队列（滑动窗口）"></a>单调队列（滑动窗口）</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><ol><li>找窗口最小值：当前元素比队尾元素更小时，队尾元素靠前并且还大，没有存在意义，当去除，由此队列是单调上升的，队头最小。</li><li>找窗口最大值：当前元素比队尾元素更大时，队尾元素靠前并且还更小，没有存在意义，当去除，由此队列是单调下降的，队头最大。</li></ol><hr><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><ol><li>构造next数组，存储当前字符在匹配的字符串前缀中最后出现的位置。</li><li>匹配中，不断试探模式串下一个是否与当前匹配，若不匹配则当前位置退一步，即next到前面某个位置继续比较。</li></ol><hr><h2 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h2><h3 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h3><ol><li>son[节点编号][所有子节点]  </li><li>分配编号采用链表形式，使用idx变量赋值编号</li></ol><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><pre><code>void insert(string s)&#123;    int now=0;    for(int i=0;i&lt;s.size();i++)&#123;        if(son[now][s[i]-&#39;a&#39;]==0)&#123;            son[now][s[i]-&#39;a&#39;]=++idx;        &#125;        now=son[now][s[i]-&#39;a&#39;];    &#125;    cnt[now]++;&#125;int query(string s)&#123;    int now=0;    for(int i=0;i&lt;s.size();i++)&#123;        if(son[now][s[i]-&#39;a&#39;]==0)return 0;        now=son[now][s[i]-&#39;a&#39;];    &#125;    return cnt[now];&#125;</code></pre><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="理解-4"><a href="#理解-4" class="headerlink" title="理解"></a>理解</h3><ol><li>初始化fa[i]&#x3D;i  </li><li>Find(int x)查找x的祖宗节点</li><li>优化：路径压缩，通过查找祖宗节点的过程回溯将所有他的子孙节点的父亲节点均改为他，这样下次查询祖宗只需要向上找一次即可。  </li><li>可以利用Find()维护很多信息</li></ol><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="理解-5"><a href="#理解-5" class="headerlink" title="理解"></a>理解</h3><ol><li>down操作</li></ol><pre><code>void down(int x)&#123;    int t=x;    //找到子节点中最小值    if(x*2&lt;=n&amp;&amp;a[x*2]&lt;a[x])t=2*x;    if(x*2+1&lt;=n&amp;&amp;a[x*2+1]&lt;a[t])t=2*x+1;    if(t!=x)&#123;        swap(a[x],a[t]);        down(t);    &#125;&#125;</code></pre><ol start="2"><li>up操作</li></ol><pre><code>void up(int x)&#123;    while(x/2&amp;&amp;a[x/2]&gt;a[x])&#123;        heap_swap(x/2,x);        x/=2;    &#125;&#125;</code></pre><hr><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ol><li>拉链法：哈希映射到h[]数组上，会存在有多个值映射在同一h[]上，因此在每个h[]下使用链表头插法加入。</li><li>开放寻址法：也称蹲坑法，就是先计算出映射值，从这个映射值开始，向后一直找有没有空位，有就进行添加。(比如你有一个固定常去的坑位上厕所，现在被人占了，那么就向后一直找看有没有没人的坑位，如果到了最后一个还没找到，就从第一个坑位继续找。)(前提坑位够)</li></ol><hr><h2 id="字符串前缀哈希"><a href="#字符串前缀哈希" class="headerlink" title="字符串前缀哈希"></a>字符串前缀哈希</h2><ol><li>利用进制思想，将每个字符串映射为一个无符号长整型，使用进制一般为131或13331可以将哈希冲突降到很低。</li><li>计算字串哈希值，可以通过前缀和a[R]-a[L]*p[R-L+1]得到，等同于数字12345想得到45，可以将12345-123x100得到。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法</title>
      <link href="/2022/12/03/11306.html"/>
      <url>/2022/12/03/11306.html</url>
      
        <content type="html"><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a><font color=red>快排</font></h2><h3 id="快排思想"><a href="#快排思想" class="headerlink" title="快排思想"></a><font color=red>快排思想</font></h3><ol><li>在待排序序列中任意取出一个值，使在它左边的数都小于等于它，在它右边的数都大于等于它。  </li><li>对所有左侧的序列进行重复的操作，对右边也是一样。  </li><li>递归退出条件：当R&#x3D;&#x3D;L时此时一定有序，return。</li></ol><h3 id="快排板子"><a href="#快排板子" class="headerlink" title="快排板子"></a><font color=purple>快排板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int a[N];void speed_sort(int L,int R)&#123;    if(L&gt;=R)return;    int x=a[L+R&gt;&gt;1];    int i=L-1,j=R+1;    while(i&lt;j)&#123;        do(i++);while(a[i]&lt;x);        do(j--);while(a[j]&gt;x);        if(i&lt;j)&#123;            swap(a[i],a[j]);        &#125;    &#125;    speed_sort(L,j);    speed_sort(j+1,R);&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    speed_sort(1,n);    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;</code></pre><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color=red>归并排序</font></h2><h3 id="归并排序思想"><a href="#归并排序思想" class="headerlink" title="归并排序思想"></a><font color=puple>归并排序思想</font></h3><ol><li>根据两个有序序列，可以进行合并成一个有序序列。</li><li>先进行递归，递归到两个序列都只有一个元素为止，此时两个序列必定有序，进行合并。</li><li>回溯，用已经有序的左右两个序列合并为一个更大的序列，直到整个序列有序。</li></ol><h3 id="归并排序板子"><a href="#归并排序板子" class="headerlink" title="归并排序板子"></a><font color=red>归并排序板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n;int a[N],b[N];void merge_sort(int L,int R)&#123;    if(L&gt;=R)return;    int M=L+R&gt;&gt;1;    merge_sort(L,M);    merge_sort(M+1,R);    int i=L,j=M+1,k=0;    while(i&lt;=M&amp;&amp;j&lt;=R)&#123;        if(a[i]&lt;a[j])b[++k]=a[i++];        else b[++k]=a[j++];    &#125;    while(i&lt;=M)b[++k]=a[i++];    while(j&lt;=R)b[++k]=a[j++];    for(int i=1,j=L;i&lt;=k;i++,j++)&#123;        a[j]=b[i];    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    merge_sort(1,n);    for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    return 0;&#125;</code></pre><hr><h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a><font color=red>高精度算法</font></h1><h2 id="高精加法"><a href="#高精加法" class="headerlink" title="高精加法"></a><font color=red>高精加法</font></h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过模拟算术加法，每位对应相加，并加上前一位产生的进位</li></ol><h3 id="高精加板子①"><a href="#高精加板子①" class="headerlink" title="高精加板子①"></a><font color=red>高精加板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    //计算    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        c[i]+=a[i]+b[i];        c[i+1]+=c[i]/10;        c[i]=c[i]%10;    &#125;    if(c[len_c+1])len_c++;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精加板子②"><a href="#高精加板子②" class="headerlink" title="高精加板子②"></a><font color=red>高精加板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N=1e5+10;string s1,s2;vector&lt;int&gt;a,b,c;int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    len=s1.size();    len=max(len,int(s2.size()));    //存储    for(int i=s1.size()-1;i&gt;=0;i--)a.push_back(s1[i]-&#39;0&#39;);    for(int i=s2.size()-1;i&gt;=0;i--)b.push_back(s2[i]-&#39;0&#39;);    //计算    int j=0;    for(int i=0;i&lt;len;i++)&#123;        int val=j;        if(i&lt;a.size())val+=a[i];        if(i&lt;b.size())val+=b[i];        j=val/10;        val%=10;        c.push_back(val);    &#125;    if(j)len++,c.push_back(j);    for(int i=len-1;i&gt;=0;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h2 id="高精减法"><a href="#高精减法" class="headerlink" title="高精减法"></a><font color=red>高精减法</font></h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>模拟算术中减法运算，逐位进行相减，不够减则向前一位借一当十使用。</li></ol><h3 id="高精减板子①"><a href="#高精减板子①" class="headerlink" title="高精减板子①"></a><font color=red>高精减板子①</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1,s2;int a[N],b[N],c[N];int len_a,len_b,len_c;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;s2;    //判断正负    bool isfu=false;    if(s1.size()==s2.size())&#123;        if(s2&gt;s1)&#123;            isfu=true;            swap(s1,s2);        &#125;    &#125;    else if(s1.size()&lt;s2.size())&#123;        isfu=true;        swap(s1,s2);    &#125;    for(int i=s1.size()-1;i&gt;=0;i--)a[++len_a]=s1[i]-&#39;0&#39;;    for(int i=s2.size()-1;i&gt;=0;i--)b[++len_b]=s2[i]-&#39;0&#39;;    len_c=max(len_a,len_b);    for(int i=1;i&lt;=len_c;i++)&#123;        //借一当十        while(a[i]-b[i]&lt;0)a[i+1]--,a[i]+=10;        c[i]=a[i]-b[i];    &#125;    //去除前导0    while(len_c&gt;1&amp;&amp;c[len_c]==0)len_c--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for(int i=len_c;i&gt;=1;i--)cout&lt;&lt;c[i];    return 0;&#125;</code></pre><h3 id="高精减板子②"><a href="#高精减板子②" class="headerlink" title="高精减板子②"></a><font color=red>高精减板子②</font></h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;vector&lt;int&gt;a, b, c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    //判断正负    bool isfu = false;    if (s1.size() == s2.size()) &#123;        if (s2 &gt; s1) &#123;            isfu = true;            swap(s1, s2);        &#125;    &#125;    else if (s1.size() &lt; s2.size()) &#123;        isfu = true;        swap(s1, s2);    &#125;    int len = s1.size();    for (int i = s1.size() - 1; i &gt;= 0; i--)a.push_back(s1[i] - &#39;0&#39;);    for (int i = s2.size() - 1; i &gt;= 0; i--)b.push_back(s2[i] - &#39;0&#39;);    int j = 0;    for (int i = 0; i &lt; len; i++) &#123;        j = a[i] - j;        if (i &lt; b.size())j -= b[i];        c.push_back((j + 10) % 10);        if (j &lt; 0)j = 1;        else j = 0;    &#125;    while (len &gt; 1 &amp;&amp; c[len - 1] == 0)len--;    if(isfu)cout&lt;&lt;&quot;-&quot;;    for (int i = len - 1; i &gt;= 0; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h2 id="高精乘法"><a href="#高精乘法" class="headerlink" title="高精乘法"></a><font color=red>高精乘法</font></h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>关键c[i+j-1]+&#x3D;a[i]*b[j]</li></ol><h3 id="高精乘板子"><a href="#高精乘板子" class="headerlink" title="高精乘板子"></a><font color=red>高精乘板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;string s1, s2;int a[N], b[N], c[N];int len_a, len_b, len_c;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = s1.size()-1; i &gt;= 0; i--)a[++len_a] = s1[i] - &#39;0&#39;;    for (int i = s2.size()-1; i &gt;= 0; i--)b[++len_b] = s2[i] - &#39;0&#39;;    len_c = len_a + len_b;    for (int i = 1; i &lt;= len_a; i++) &#123;        for (int j = 1; j &lt;= len_b; j++) &#123;            c[i + j - 1] += a[i] * b[j];            c[i + j] += c[i + j - 1] / 10;            c[i + j - 1] %= 10;        &#125;    &#125;    while (c[len_c] == 0 &amp;&amp; len_c &gt; 1)len_c--;    for (int i = len_c; i &gt;= 1; i--)cout &lt;&lt; c[i];    return 0;&#125;</code></pre><h2 id="高精除法（大整数-x2F-小整数）"><a href="#高精除法（大整数-x2F-小整数）" class="headerlink" title="高精除法（大整数&#x2F;小整数）"></a><font color=red>高精除法（大整数&#x2F;小整数）</font></h2><h3 id="高精除板子"><a href="#高精除板子" class="headerlink" title="高精除板子"></a><font color=red>高精除板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;string s1;int b,a[N],c[N];int len;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;s1&gt;&gt;b;    for(int i=0;i&lt;=s1.size()-1;i++)a[++len]=s1[i]-&#39;0&#39;;    //余数    int yu=0;    for(int i=1;i&lt;=len;i++)&#123;        c[i]=(yu*10+a[i])/b;        yu=(yu*10+a[i])%b;    &#125;    int xb=0;    //注意前导0的去除    while(c[xb]==0&amp;&amp;xb&lt;len)xb++;    for(int i=xb;i&lt;=len;i++)cout&lt;&lt;c[i];    cout&lt;&lt;endl&lt;&lt;yu;    return 0;&#125;</code></pre><hr><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a><font color=red>一维前缀和</font></h2><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过计算前缀和，得到前缀和数组，可以计算任意区间的总和值。</li></ol><h3 id="一维前缀和板子"><a href="#一维前缀和板子" class="headerlink" title="一维前缀和板子"></a><font color=red>一维前缀和板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n,a[N],m;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],a[i]+=a[i-1];    while(m--)&#123;        int L,R;        cin&gt;&gt;L&gt;&gt;R;        cout&lt;&lt;a[R]-a[L-1]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a><font color=red>二维前缀和</font></h2><h3 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>前缀和b[i][j]&#x3D;b[i-1][j]+b[i][j-1]+a[i][j]</li><li>区间和b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]</li><li>画图便于理解</li></ol><h3 id="二维前缀和板子"><a href="#二维前缀和板子" class="headerlink" title="二维前缀和板子"></a><font color=red></font>二维前缀和板子</h3><pre><code>#include&lt;iostream&gt;using namespace std;int n,m,q;int a[1003][1003],b[1003][1003];int x1,y1,x2,y2;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;a[i][j];            b[i][j]=b[i-1][j]+b[i][j-1]+a[i][j]-b[i-1][j-1];        &#125;    &#125;    while(q--)&#123;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;        cout&lt;&lt;b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><hr><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a><font color=red>二分</font></h2><h3 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a><font color=puple>二分思想</font></h3><ol><li>对于某个单调序列，查找某个值x在序列中的大致位置（不保证序列中这个值一定存在）通过判断x与序列中点的值，从而确定下次去左半边区间找，还是去右半边区间找。这样最多只需要log(n)次便可找到。</li><li>需要特别注意边界问题，如下两个二分板子</li></ol><h3 id="二分板子"><a href="#二分板子" class="headerlink" title="二分板子"></a><font color=red>二分板子</font></h3><pre><code>int Find_1(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R&gt;&gt;1;        if(a[M]&gt;=x)R=M;        else L=M+1;    &#125;    return L;&#125;int Find_2(int x)&#123;    int L=1,R=n;    while(R&gt;L)&#123;        int M=L+R+1&gt;&gt;1;        if(a[M]&lt;=x)L=M;        else R=M-1;    &#125;    return L;&#125;</code></pre><hr><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a><font color=red>一维差分</font></h2><h3 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>通过b[L]+&#x3D;c;b[R+1]-&#x3D;c，对差分数组两端点修改，从而再利用前缀和达到对整个区间段修改。</li><li>复杂度降到O(1)</li></ol><h3 id="一维差分板子"><a href="#一维差分板子" class="headerlink" title="一维差分板子"></a><font color=red>一维差分板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int n,m;int a[N],b[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    while(m--)&#123;        int L,R,c;        cin&gt;&gt;L&gt;&gt;R&gt;&gt;c;        b[L]+=c;b[R+1]-=c;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        b[i]+=b[i-1];        a[i]+=b[i];        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;</code></pre><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a><font color=red>二维差分</font></h2><h3 id="思想-6"><a href="#思想-6" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>核心：b[x1][y2+1]-&#x3D;c;<br> b[x2+1][y1]-&#x3D;c;<br> b[x1][y1]+&#x3D;c;<br> b[x2+1][y2+1]+&#x3D;c;</li></ol><h3 id="二维差分板子"><a href="#二维差分板子" class="headerlink" title="二维差分板子"></a><font color=red>二维差分板子</font></h3><pre><code>#include&lt;iostream&gt;using namespace std;int a[1003][1003],b[1003][1003];int n,m,q;int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    while(q--)&#123;        int x1,y1,x2,y2,c;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;        b[x1][y2+1]-=c;        b[x2+1][y1]-=c;        b[x1][y1]+=c;        b[x2+1][y2+1]+=c;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];            a[i][j]+=b[i][j];            cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><hr><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><font color=red>双指针</font></h2><h3 id="思想-7"><a href="#思想-7" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li><p>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )<br> {<br> while (j &lt; i &amp;&amp; check(i, j)) j ++ ;</p><p> &#x2F;&#x2F; 具体问题的逻辑}</p></li></ol><hr><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a><font color=red>二进制</font></h2><h3 id="lowbit求二进制表示中最后一个一的位置"><a href="#lowbit求二进制表示中最后一个一的位置" class="headerlink" title="lowbit求二进制表示中最后一个一的位置"></a><font color=puple>lowbit求二进制表示中最后一个一的位置</font></h3><ol><li>int lowbit(int x){<br> return x&amp;-x;<br>}</li></ol><hr><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><h3 id="思想-8"><a href="#思想-8" class="headerlink" title="思想"></a><font color=puple>思想</font></h3><ol><li>适用类型：范围很大的一组数据，但是总个数少。</li><li>将原先一组数据映射到新的数组中，根据需要进行排序或去重，可以在排序后通过二分找到原先数组中对应元素在新数组中对应的位置，从而进行后续的操作。</li></ol><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ol><li><font color=puple>排序</font>：sort(num.begin(),num.end());</li><li><font color=puple>去重</font>：num.erase(unique(num.begin(),num.end()),num.end());</li></ol><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
